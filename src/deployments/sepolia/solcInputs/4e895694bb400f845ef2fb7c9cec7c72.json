{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     *\n     * Setting `newOwner` to the zero address is allowed; this can be used to cancel an initiated ownership transfer.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/dutchAuctionConfidential/DutchAuctionSellConfERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"fhevm/lib/TFHE.sol\";\nimport { ConfidentialERC20 } from \"fhevm-contracts/contracts/token/ERC20/ConfidentialERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"fhevm/config/ZamaFHEVMConfig.sol\";\nimport \"fhevm/config/ZamaGatewayConfig.sol\";\nimport \"fhevm/gateway/GatewayCaller.sol\";\n\n/// @title Dutch Auction for Selling Confidential ERC20 Tokens\n/// @notice Implements a Dutch auction mechanism for selling confidential ERC20 tokens\n/// @dev Uses FHEVM for handling encrypted values and transactions\ncontract DutchAuctionSellingConfidentialERC20 is\n    SepoliaZamaFHEVMConfig,\n    SepoliaZamaGatewayConfig,\n    GatewayCaller,\n    Ownable2Step\n{\n    /// @notice The ERC20 token being auctioned\n    ConfidentialERC20 public immutable token;\n    /// @notice The token used for payments\n    ConfidentialERC20 public immutable paymentToken;\n    /// @notice Encrypted amount of tokens remaining in the auction\n    euint64 private tokensLeft;\n\n    /// @notice Address of the seller\n    address payable public immutable seller;\n    /// @notice Initial price per token\n    uint64 public immutable startingPrice;\n    /// @notice Rate at which the price decreases\n    uint64 public immutable discountRate;\n    /// @notice Timestamp when the auction starts\n    uint256 public immutable startAt;\n    /// @notice Timestamp when the auction ends\n    uint256 public immutable expiresAt;\n    /// @notice Minimum price per token\n    uint64 public immutable reservePrice;\n    /// @notice Total amount of tokens being auctioned\n    uint64 public immutable amount;\n    /// @notice Flag indicating if the auction has started\n    bool public auctionStart = false;\n\n    /// @notice Flag to determine if the auction can be stopped manually\n    bool public stoppable;\n\n    /// @notice Flag to check if the auction has been manually stopped\n    bool public manuallyStopped = false;\n\n    /// @notice Decrypted value of remaining tokens\n    uint64 public tokensLeftReveal;\n\n    /// @notice Structure to store bid information\n    /// @param tokenAmount Amount of tokens bid for\n    /// @param paidAmount Amount paid for the tokens\n    struct Bid {\n        euint64 tokenAmount;\n        euint64 paidAmount;\n    }\n    /// @notice Mapping of addresses to their bids\n    mapping(address => Bid) public bids;\n\n    /// @notice Emitted when a bid is submitted\n    /// @param buyer Address of the bidder\n    /// @param pricePerToken Price per token at the time of bid\n    event BidSubmitted(address indexed buyer, uint pricePerToken);\n\n    /// @notice Error thrown when a function is called too early\n    /// @dev Includes the time when the function can be called\n    error TooEarly(uint256 time);\n\n    /// @notice Error thrown when a function is called too late\n    /// @dev Includes the time after which the function cannot be called\n    error TooLate(uint256 time);\n\n    /// @notice Error thrown when trying to start an already started auction\n    error AuctionAlreadyStarted();\n    /// @notice Error thrown when trying to interact with an unstarted auction\n    error AuctionNotStarted();\n\n    /// @notice Creates a new Dutch auction contract\n    /// @param _startingPrice Initial price per token\n    /// @param _discountRate Rate at which price decreases\n    /// @param _token Address of token being auctioned\n    /// @param _paymentToken Address of token used for payment\n    /// @param _amount Total amount of tokens to auction\n    /// @param _reservePrice Minimum price per token\n    /// @param _biddingTime Duration of the auction in seconds\n    /// @param _isStoppable Whether the auction can be stopped manually\n    constructor(\n        uint64 _startingPrice,\n        uint64 _discountRate,\n        ConfidentialERC20 _token,\n        ConfidentialERC20 _paymentToken,\n        uint64 _amount,\n        uint64 _reservePrice,\n        uint256 _biddingTime,\n        bool _isStoppable\n    ) Ownable(msg.sender) {\n        seller = payable(msg.sender);\n        startingPrice = _startingPrice;\n        discountRate = _discountRate;\n        startAt = block.timestamp;\n        expiresAt = block.timestamp + _biddingTime;\n        reservePrice = _reservePrice;\n        stoppable = _isStoppable;\n\n        require(_startingPrice >= _discountRate * _biddingTime + _reservePrice, \"Starting price too low\");\n        require(_reservePrice > 0, \"Reserve price must be greater than zero\");\n        require(_startingPrice > _reservePrice, \"Starting price must be greater than reserve price\");\n\n        amount = _amount; // initial amount should be known\n        tokensLeft = TFHE.asEuint64(_amount);\n        tokensLeftReveal = _amount;\n        token = _token;\n        paymentToken = _paymentToken;\n        TFHE.allowThis(tokensLeft);\n        TFHE.allow(tokensLeft, owner());\n    }\n\n    /// @notice Initializes the auction by transferring tokens from seller\n    /// @dev Can only be called once by the owner\n    function initialize() external onlyOwner {\n        if (auctionStart) revert AuctionAlreadyStarted();\n\n        euint64 encAmount = TFHE.asEuint64(amount);\n\n        TFHE.allowTransient(encAmount, address(token));\n\n        // Transfer tokens from seller to the auction contract\n        token.transferFrom(msg.sender, address(this), encAmount);\n\n        euint64 balanceAfter = token.balanceOf(address(this));\n\n        ebool encAuctionStart = TFHE.select(TFHE.ge(balanceAfter, amount), TFHE.asEbool(true), TFHE.asEbool(false));\n\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(encAuctionStart);\n        Gateway.requestDecryption(cts, this.callbackBool.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Callback function for boolean decryption\n    /// @dev Only callable by the Gateway contract\n    /// @param encAuctionStart The decrypted boolean\n    /// @return The decrypted value\n    function callbackBool(uint256, bool encAuctionStart) public onlyGateway returns (bool) {\n        auctionStart = encAuctionStart;\n        return encAuctionStart;\n    }\n\n    /// @notice Gets the current price per token\n    /// @dev Price decreases linearly over time until it reaches reserve price\n    /// @return Current price per token in payment token units\n    function getPrice() public view returns (uint64) {\n        if (block.timestamp >= expiresAt) {\n            return reservePrice;\n        }\n\n        uint256 timeElapsed = block.timestamp - startAt;\n        uint256 discount = discountRate * timeElapsed;\n        uint64 currentPrice = startingPrice > uint64(discount) ? startingPrice - uint64(discount) : 0;\n        return currentPrice > reservePrice ? currentPrice : reservePrice;\n    }\n\n    /// @notice Manually stop the auction\n    /// @dev Can only be called by the owner and if the auction is stoppable\n    function stop() external onlyOwner {\n        require(stoppable);\n        manuallyStopped = true;\n    }\n\n    /// @notice Submit a bid for tokens\n    /// @dev Handles bid logic including refunds from previous bids\n    /// @param encryptedValue Encrypted amount of tokens to bid for\n    /// @param inputProof Zero-knowledge proof for the encrypted input\n    function bid(einput encryptedValue, bytes calldata inputProof) external onlyBeforeEnd {\n        euint64 newTokenAmount = TFHE.asEuint64(encryptedValue, inputProof);\n        uint64 currentPricePerToken = getPrice();\n\n        // Calculate how many new tokens can be bought\n        newTokenAmount = TFHE.min(newTokenAmount, tokensLeft);\n\n        // Handle previous bid adjustments\n        Bid storage userBid = bids[msg.sender];\n\n        if (TFHE.isInitialized(userBid.tokenAmount)) {\n            // Previous bid exists - calculate total tokens bought and amount paid\n            euint64 totalTokenAmount = TFHE.add(newTokenAmount, userBid.tokenAmount);\n            euint64 oldPaidAmount = userBid.paidAmount;\n\n            // Calculate cost of total token at current price\n            euint64 totalCostAtNewPrice = TFHE.mul(currentPricePerToken, totalTokenAmount);\n\n            // Calculate difference between paid already and new price\n            ebool totalBiggerOld = TFHE.ge(totalCostAtNewPrice, oldPaidAmount);\n            euint64 paidDiff = TFHE.sub(totalCostAtNewPrice, oldPaidAmount);\n            euint64 amountToTransfer = TFHE.select(totalBiggerOld, paidDiff, TFHE.asEuint64(0));\n            euint64 amountToRefund = TFHE.sub(amountToTransfer, paidDiff);\n\n            // Transfer money, and only if OK send the tokens and process refund\n            euint64 transferredBalance = _handleTransfer(amountToTransfer);\n            ebool transferOK = TFHE.eq(transferredBalance, amountToTransfer);\n\n            // Transfer tokens and refund\n            euint64 finalTokenAmountToTransfer = TFHE.select(transferOK, newTokenAmount, TFHE.asEuint64(0));\n            _handleTokenTransfer(finalTokenAmountToTransfer);\n\n            euint64 finalAmountToRefund = TFHE.select(transferOK, amountToRefund, TFHE.asEuint64(0));\n            _handleRefund(finalAmountToRefund);\n\n            // Update bid\n            euint64 finalTotalTokens = TFHE.select(transferOK, totalTokenAmount, userBid.tokenAmount);\n            euint64 finalTotalCost = TFHE.select(transferOK, totalCostAtNewPrice, userBid.paidAmount);\n            _updateBidInfo(finalTotalTokens, finalTotalCost, finalTokenAmountToTransfer);\n        } else {\n            // Amount of money to pay\n            euint64 amountToTransfer = TFHE.mul(currentPricePerToken, newTokenAmount);\n\n            // Transfer money, and only if OK send the tokens\n            euint64 transferredBalance = _handleTransfer(amountToTransfer);\n            ebool transferOK = TFHE.eq(transferredBalance, amountToTransfer);\n\n            // Transfer tokens\n            euint64 tokensToTransfer = TFHE.select(transferOK, newTokenAmount, TFHE.asEuint64(0));\n            _handleTokenTransfer(tokensToTransfer);\n\n            // Update bid\n            _updateBidInfo(tokensToTransfer, transferredBalance, tokensToTransfer);\n        }\n\n        emit BidSubmitted(msg.sender, currentPricePerToken);\n    }\n\n    /// @dev Helper function to handle token transfers\n    function _handleTransfer(euint64 amountToTransfer) private returns (euint64) {\n        euint64 balanceBefore = paymentToken.balanceOf(address(this));\n        TFHE.allowTransient(amountToTransfer, address(paymentToken));\n        paymentToken.transferFrom(msg.sender, address(this), amountToTransfer);\n        euint64 balanceAfter = paymentToken.balanceOf(address(this));\n        return TFHE.sub(balanceAfter, balanceBefore);\n    }\n\n    /// @dev Helper function to handle refunds\n    function _handleRefund(euint64 amountToTransfer) private {\n        TFHE.allowTransient(amountToTransfer, address(paymentToken));\n        paymentToken.transfer(msg.sender, amountToTransfer);\n    }\n\n    /// @dev Helper function to handle token transfer\n    function _handleTokenTransfer(euint64 amountToTransfer) private {\n        TFHE.allowTransient(amountToTransfer, address(token));\n        token.transfer(msg.sender, amountToTransfer);\n    }\n\n    /// @dev Helper function to update bid information\n    function _updateBidInfo(euint64 totalTokenAmount, euint64 totalPaidAmount, euint64 newTokenAmount) private {\n        bids[msg.sender].tokenAmount = totalTokenAmount;\n        bids[msg.sender].paidAmount = totalPaidAmount;\n        TFHE.allowThis(bids[msg.sender].tokenAmount);\n        TFHE.allowThis(bids[msg.sender].paidAmount);\n        TFHE.allow(bids[msg.sender].tokenAmount, msg.sender);\n        TFHE.allow(bids[msg.sender].paidAmount, msg.sender);\n\n        // Update remaining tokens\n        tokensLeft = TFHE.sub(tokensLeft, newTokenAmount);\n        TFHE.allowThis(tokensLeft);\n        TFHE.allow(tokensLeft, owner());\n    }\n\n    /// @notice Claim tokens and refund for a bidder after auction ends\n    /// @dev Transfers tokens to bidder and refunds excess payment based on final price\n    function claimUserRefund() external onlyAfterAuctionEnds {\n        Bid storage userBid = bids[msg.sender];\n\n        uint finalPrice = getPrice();\n        euint64 finalPricePerToken = TFHE.asEuint64(finalPrice);\n        euint64 finalCost = TFHE.mul(finalPricePerToken, userBid.tokenAmount);\n        euint64 refundAmount = TFHE.sub(userBid.paidAmount, finalCost);\n\n        // Transfer refund\n        _handleRefund(refundAmount);\n\n        // Clear the bid\n        delete bids[msg.sender];\n    }\n\n    /// @notice Claim proceeds for the seller after auction ends\n    /// @dev Transfers all remaining tokens and payments to seller\n    function claimSeller() external onlyOwner onlyAfterAuctionEnds {\n        // Transfer remaining auction tokens back to seller\n        TFHE.allowTransient(tokensLeft, address(token));\n        token.transfer(seller, tokensLeft);\n\n        // Get current price\n        uint64 endPricePerToken = getPrice();\n\n        // Calculate and transfer payment tokens to seller\n        euint64 contractAuctionBalance = TFHE.mul(endPricePerToken, TFHE.sub(TFHE.asEuint64(amount), tokensLeft));\n        TFHE.allowTransient(contractAuctionBalance, address(paymentToken));\n        paymentToken.transfer(seller, contractAuctionBalance);\n\n        tokensLeft = TFHE.asEuint64(0);\n        TFHE.allowThis(tokensLeft);\n        TFHE.allow(tokensLeft, owner());\n    }\n\n    /// @notice Request decryption of remaining tokens\n    /// @dev Only owner can request decryption\n    function requestTokensLeftReveal() public onlyOwner {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(tokensLeft);\n        Gateway.requestDecryption(cts, this.callbackUint64.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Callback function for 64-bit unsigned integer decryption\n    /// @dev Only callable by the Gateway contract\n    /// @param decryptedInput The decrypted 64-bit unsigned integer\n    /// @return The decrypted value\n    function callbackUint64(uint256, uint64 decryptedInput) public onlyGateway returns (uint64) {\n        tokensLeftReveal = decryptedInput;\n        return decryptedInput;\n    }\n\n    /// @notice Cancel the auction and return tokens to seller\n    /// @dev Only owner can cancel before auction ends\n    function cancelAuction() external onlyOwner onlyBeforeEnd {\n        TFHE.allowTransient(tokensLeft, address(token));\n\n        // Refund remaining tokens\n        token.transfer(seller, tokensLeft);\n    }\n\n    /// @notice Modifier to ensure function is called before auction ends\n    /// @dev Reverts if called after the auction end time or if manually stopped\n    modifier onlyBeforeEnd() {\n        if (!auctionStart) revert AuctionNotStarted();\n        if (block.timestamp >= expiresAt || manuallyStopped == true) revert TooLate(expiresAt);\n        _;\n    }\n\n    /// @notice Modifier to ensure function is called after auction ends\n    /// @dev Reverts if called before the auction end time and called after claims time expire and not manually stopped\n    modifier onlyAfterAuctionEnds() {\n        if (!auctionStart) revert AuctionNotStarted();\n        if (block.timestamp < expiresAt && manuallyStopped == false) revert TooEarly(expiresAt);\n        _;\n    }\n    /// @notice Get the user's current bid information\n    /// @dev Returns the decrypted values of token amount and paid amount\n    /// @return tokenAmount Amount of tokens bid for\n    /// @return paidAmount Amount paid for the tokens\n    function getUserBid() external view returns (euint64 tokenAmount, euint64 paidAmount) {\n        Bid storage userBid = bids[msg.sender];\n        return (userBid.tokenAmount, userBid.paidAmount);\n    }\n}\n"
    },
    "contracts/dutchAuctionConfidential/DutchAuctionSellConfERC20NoRefund.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"fhevm/lib/TFHE.sol\";\nimport { ConfidentialERC20 } from \"fhevm-contracts/contracts/token/ERC20/ConfidentialERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"fhevm/config/ZamaFHEVMConfig.sol\";\nimport \"fhevm/config/ZamaGatewayConfig.sol\";\nimport \"fhevm/gateway/GatewayCaller.sol\";\n\n/// @title Dutch Auction for Selling Confidential ERC20 Tokens\n/// @notice Implements a Dutch auction mechanism for selling confidential ERC20 tokens\n/// @dev Uses FHEVM for handling encrypted values and transactions\ncontract DutchAuctionSellingConfidentialERC20NoRefund is\n    SepoliaZamaFHEVMConfig,\n    SepoliaZamaGatewayConfig,\n    GatewayCaller,\n    Ownable2Step\n{\n    /// @notice The ERC20 token being auctioned\n    ConfidentialERC20 public immutable token;\n    /// @notice The token used for payments\n    ConfidentialERC20 public immutable paymentToken;\n    /// @notice Encrypted amount of tokens remaining in the auction\n    euint64 private tokensLeft;\n\n    /// @notice Address of the seller\n    address payable public immutable seller;\n    /// @notice Initial price per token\n    uint64 public immutable startingPrice;\n    /// @notice Rate at which the price decreases\n    uint64 public immutable discountRate;\n    /// @notice Timestamp when the auction starts\n    uint256 public immutable startAt;\n    /// @notice Timestamp when the auction ends\n    uint256 public immutable expiresAt;\n    /// @notice Minimum price per token\n    uint64 public immutable reservePrice;\n    /// @notice Total amount of tokens being auctioned\n    uint64 public immutable amount;\n    /// @notice Flag indicating if the auction has started\n    bool public auctionStart = false;\n\n    /// @notice Flag to determine if the auction can be stopped manually\n    bool public stoppable;\n\n    /// @notice Flag to check if the auction has been manually stopped\n    bool public manuallyStopped = false;\n\n    /// @notice Decrypted value of remaining tokens\n    uint64 public tokensLeftReveal;\n\n    /// @notice Structure to store bid information\n    /// @param tokenAmount Amount of tokens bid for\n    /// @param paidAmount Amount paid for the tokens\n    struct Bid {\n        euint64 tokenAmount;\n        euint64 paidAmount;\n    }\n    /// @notice Mapping of addresses to their bids\n    mapping(address => Bid) public bids;\n\n    /// @notice Emitted when a bid is submitted\n    /// @param buyer Address of the bidder\n    /// @param pricePerToken Price per token at the time of bid\n    event BidSubmitted(address indexed buyer, uint pricePerToken);\n\n    /// @notice Error thrown when a function is called too early\n    /// @dev Includes the time when the function can be called\n    error TooEarly(uint256 time);\n\n    /// @notice Error thrown when a function is called too late\n    /// @dev Includes the time after which the function cannot be called\n    error TooLate(uint256 time);\n\n    /// @notice Error thrown when trying to start an already started auction\n    error AuctionAlreadyStarted();\n    /// @notice Error thrown when trying to interact with an unstarted auction\n    error AuctionNotStarted();\n\n    /// @notice Creates a new Dutch auction contract\n    /// @param _startingPrice Initial price per token\n    /// @param _discountRate Rate at which price decreases\n    /// @param _token Address of token being auctioned\n    /// @param _paymentToken Address of token used for payment\n    /// @param _amount Total amount of tokens to auction\n    /// @param _reservePrice Minimum price per token\n    /// @param _biddingTime Duration of the auction in seconds\n    /// @param _isStoppable Whether the auction can be stopped manually\n    constructor(\n        uint64 _startingPrice,\n        uint64 _discountRate,\n        ConfidentialERC20 _token,\n        ConfidentialERC20 _paymentToken,\n        uint64 _amount,\n        uint64 _reservePrice,\n        uint256 _biddingTime,\n        bool _isStoppable\n    ) Ownable(msg.sender) {\n        seller = payable(msg.sender);\n        startingPrice = _startingPrice;\n        discountRate = _discountRate;\n        startAt = block.timestamp;\n        expiresAt = block.timestamp + _biddingTime;\n        reservePrice = _reservePrice;\n        stoppable = _isStoppable;\n\n        require(_startingPrice >= _discountRate * _biddingTime + _reservePrice, \"Starting price too low\");\n        require(_reservePrice > 0, \"Reserve price must be greater than zero\");\n        require(_startingPrice > _reservePrice, \"Starting price must be greater than reserve price\");\n\n        amount = _amount; // initial amount should be known\n        tokensLeft = TFHE.asEuint64(_amount);\n        tokensLeftReveal = _amount;\n        token = _token;\n        paymentToken = _paymentToken;\n        TFHE.allowThis(tokensLeft);\n        TFHE.allow(tokensLeft, owner());\n    }\n\n    /// @notice Initializes the auction by transferring tokens from seller\n    /// @dev Can only be called once by the owner\n    function initialize() external onlyOwner {\n        if (auctionStart) revert AuctionAlreadyStarted();\n\n        euint64 encAmount = TFHE.asEuint64(amount);\n\n        TFHE.allowTransient(encAmount, address(token));\n\n        // Transfer tokens from seller to the auction contract\n        token.transferFrom(msg.sender, address(this), encAmount);\n\n        euint64 balanceAfter = token.balanceOf(address(this));\n\n        ebool encAuctionStart = TFHE.select(TFHE.ge(balanceAfter, amount), TFHE.asEbool(true), TFHE.asEbool(false));\n\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(encAuctionStart);\n        Gateway.requestDecryption(cts, this.callbackBool.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Callback function for boolean decryption\n    /// @dev Only callable by the Gateway contract\n    /// @param encAuctionStart The decrypted boolean\n    /// @return The decrypted value\n    function callbackBool(uint256, bool encAuctionStart) public onlyGateway returns (bool) {\n        auctionStart = encAuctionStart;\n        return encAuctionStart;\n    }\n\n    /// @notice Gets the current price per token\n    /// @dev Price decreases linearly over time until it reaches reserve price\n    /// @return Current price per token in payment token units\n    function getPrice() public view returns (uint64) {\n        if (block.timestamp >= expiresAt) {\n            return reservePrice;\n        }\n\n        uint256 timeElapsed = block.timestamp - startAt;\n        uint256 discount = discountRate * timeElapsed;\n        uint64 currentPrice = startingPrice > uint64(discount) ? startingPrice - uint64(discount) : 0;\n        return currentPrice > reservePrice ? currentPrice : reservePrice;\n    }\n\n    /// @notice Manually stop the auction\n    /// @dev Can only be called by the owner and if the auction is stoppable\n    function stop() external onlyOwner {\n        require(stoppable);\n        manuallyStopped = true;\n    }\n\n    /// @notice Submit a bid for tokens\n    /// @dev Handles bid logic including refunds from previous bids\n    /// @param encryptedValue Encrypted amount of tokens to bid for\n    /// @param inputProof Zero-knowledge proof for the encrypted input\n    function bid(einput encryptedValue, bytes calldata inputProof) external onlyBeforeEnd {\n        euint64 newTokenAmount = TFHE.asEuint64(encryptedValue, inputProof);\n        uint64 currentPricePerToken = getPrice();\n\n        // Calculate how many new tokens can be bought\n        newTokenAmount = TFHE.min(newTokenAmount, tokensLeft);\n\n        // Amount of money to pay\n        euint64 amountToTransfer = TFHE.mul(currentPricePerToken, newTokenAmount);\n\n        // Transfer money, and only if OK send the tokens\n        euint64 transferredBalance = _handleTransfer(amountToTransfer);\n        ebool transferOK = TFHE.eq(transferredBalance, amountToTransfer);\n\n        // Transfer tokens\n        euint64 tokensToTransfer = TFHE.select(transferOK, newTokenAmount, TFHE.asEuint64(0));\n        _handleTokenTransfer(tokensToTransfer);\n\n        // Update bid\n        _updateBidInfo(tokensToTransfer, transferredBalance);\n\n        emit BidSubmitted(msg.sender, currentPricePerToken);\n    }\n\n    /// @dev Helper function to handle token transfers\n    function _handleTransfer(euint64 amountToTransfer) private returns (euint64) {\n        euint64 balanceBefore = paymentToken.balanceOf(address(this));\n        TFHE.allowTransient(amountToTransfer, address(paymentToken));\n        paymentToken.transferFrom(msg.sender, address(this), amountToTransfer);\n        euint64 balanceAfter = paymentToken.balanceOf(address(this));\n        return TFHE.sub(balanceAfter, balanceBefore);\n    }\n\n    /// @dev Helper function to handle refunds\n    function _handleRefund(euint64 amountToTransfer) private {\n        TFHE.allowTransient(amountToTransfer, address(paymentToken));\n        paymentToken.transfer(msg.sender, amountToTransfer);\n    }\n\n    /// @dev Helper function to handle token transfer\n    function _handleTokenTransfer(euint64 amountToTransfer) private {\n        TFHE.allowTransient(amountToTransfer, address(token));\n        token.transfer(msg.sender, amountToTransfer);\n    }\n\n    /// @dev Helper function to update bid information\n    function _updateBidInfo(euint64 newTokenAmount, euint64 newPaidAmount) private {\n        // Handle previous bid adjustments\n        Bid storage userBid = bids[msg.sender];\n\n        if (TFHE.isInitialized(userBid.tokenAmount)) {\n            bids[msg.sender].tokenAmount = TFHE.add(newTokenAmount, bids[msg.sender].tokenAmount);\n            bids[msg.sender].paidAmount = TFHE.add(newPaidAmount, bids[msg.sender].paidAmount);\n        } else {\n            bids[msg.sender].tokenAmount = newTokenAmount;\n            bids[msg.sender].paidAmount = newPaidAmount;\n        }\n        TFHE.allowThis(bids[msg.sender].tokenAmount);\n        TFHE.allowThis(bids[msg.sender].paidAmount);\n        TFHE.allow(bids[msg.sender].tokenAmount, msg.sender);\n        TFHE.allow(bids[msg.sender].paidAmount, msg.sender);\n\n        // Update remaining tokens\n        tokensLeft = TFHE.sub(tokensLeft, newTokenAmount);\n        TFHE.allowThis(tokensLeft);\n        TFHE.allow(tokensLeft, owner());\n    }\n\n    /// @notice Claim tokens and refund for a bidder after auction ends\n    /// @dev Transfers tokens to bidder and refunds excess payment based on final price\n    function claimUserRefund() external onlyAfterAuctionEnds {\n        Bid storage userBid = bids[msg.sender];\n\n        uint finalPrice = getPrice();\n        euint64 finalPricePerToken = TFHE.asEuint64(finalPrice);\n        euint64 finalCost = TFHE.mul(finalPricePerToken, userBid.tokenAmount);\n        euint64 refundAmount = TFHE.sub(userBid.paidAmount, finalCost);\n\n        // Transfer refund\n        _handleRefund(refundAmount);\n\n        // Clear the bid\n        delete bids[msg.sender];\n    }\n\n    /// @notice Claim proceeds for the seller after auction ends\n    /// @dev Transfers all remaining tokens and payments to seller\n    function claimSeller() external onlyOwner onlyAfterAuctionEnds {\n        // Transfer remaining auction tokens back to seller\n        TFHE.allowTransient(tokensLeft, address(token));\n        token.transfer(seller, tokensLeft);\n\n        // Get current price\n        uint64 endPricePerToken = getPrice();\n\n        // Calculate and transfer payment tokens to seller\n        euint64 contractAuctionBalance = TFHE.mul(endPricePerToken, TFHE.sub(TFHE.asEuint64(amount), tokensLeft));\n        TFHE.allowTransient(contractAuctionBalance, address(paymentToken));\n        paymentToken.transfer(seller, contractAuctionBalance);\n\n        tokensLeft = TFHE.asEuint64(0);\n        TFHE.allowThis(tokensLeft);\n        TFHE.allow(tokensLeft, owner());\n    }\n\n    /// @notice Request decryption of remaining tokens\n    /// @dev Only owner can request decryption\n    function requestTokensLeftReveal() public onlyOwner {\n        uint256[] memory cts = new uint256[](1);\n        cts[0] = Gateway.toUint256(tokensLeft);\n        Gateway.requestDecryption(cts, this.callbackUint64.selector, 0, block.timestamp + 100, false);\n    }\n\n    /// @notice Callback function for 64-bit unsigned integer decryption\n    /// @dev Only callable by the Gateway contract\n    /// @param decryptedInput The decrypted 64-bit unsigned integer\n    /// @return The decrypted value\n    function callbackUint64(uint256, uint64 decryptedInput) public onlyGateway returns (uint64) {\n        tokensLeftReveal = decryptedInput;\n        return decryptedInput;\n    }\n\n    /// @notice Cancel the auction and return tokens to seller\n    /// @dev Only owner can cancel before auction ends\n    function cancelAuction() external onlyOwner onlyBeforeEnd {\n        TFHE.allowTransient(tokensLeft, address(token));\n\n        // Refund remaining tokens\n        token.transfer(seller, tokensLeft);\n    }\n\n    /// @notice Modifier to ensure function is called before auction ends\n    /// @dev Reverts if called after the auction end time or if manually stopped\n    modifier onlyBeforeEnd() {\n        if (!auctionStart) revert AuctionNotStarted();\n        if (block.timestamp >= expiresAt || manuallyStopped == true) revert TooLate(expiresAt);\n        _;\n    }\n\n    /// @notice Modifier to ensure function is called after auction ends\n    /// @dev Reverts if called before the auction end time and called after claims time expire and not manually stopped\n    modifier onlyAfterAuctionEnds() {\n        if (!auctionStart) revert AuctionNotStarted();\n        if (block.timestamp < expiresAt && manuallyStopped == false) revert TooEarly(expiresAt);\n        _;\n    }\n\n    /// @notice Get the user's current bid information\n    /// @dev Returns the decrypted values of token amount and paid amount\n    /// @return tokenAmount Amount of tokens bid for\n    /// @return paidAmount Amount paid for the tokens\n    function getUserBid() external view returns (euint64 tokenAmount, euint64 paidAmount) {\n        Bid storage userBid = bids[msg.sender];\n        return (userBid.tokenAmount, userBid.paidAmount);\n    }\n}\n"
    },
    "contracts/erc20/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialHolder,\n        uint256 initialSupply\n    ) ERC20(name, symbol) {\n        _mint(initialHolder, initialSupply);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n}\n"
    },
    "contracts/erc20/MyConfidentialERC20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\nimport \"fhevm/config/ZamaFHEVMConfig.sol\";\nimport \"fhevm-contracts/contracts/token/ERC20/extensions/ConfidentialERC20WithErrorsMintable.sol\";\n\n/// @notice This contract implements an encrypted ERC20-like token with confidential balances using Zama's FHE library.\n/// @dev It supports typical ERC20 functionality such as transferring tokens, minting, and setting allowances,\n/// @dev but uses encrypted data types.\ncontract MyConfidentialERC20 is SepoliaZamaFHEVMConfig, ConfidentialERC20WithErrorsMintable {\n    /// @notice Constructor to initialize the token's name and symbol, and set up the owner\n    /// @param name_ The name of the token\n    /// @param symbol_ The symbol of the token\n    constructor(\n        string memory name_,\n        string memory symbol_\n    ) ConfidentialERC20WithErrorsMintable(name_, symbol_, msg.sender) {}\n}\n"
    },
    "fhevm-contracts/contracts/token/ERC20/ConfidentialERC20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\nimport { IERC20Errors } from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport { IConfidentialERC20 } from \"./IConfidentialERC20.sol\";\nimport { TFHEErrors } from \"../../utils/TFHEErrors.sol\";\n\n/**\n * @title   ConfidentialERC20.\n * @notice  This contract implements an encrypted ERC20-like token with confidential balances using\n *          Zama's FHE (Fully Homomorphic Encryption) library.\n * @dev     It supports standard ERC20 functions such as transferring tokens, minting,\n *          and setting allowances, but uses encrypted data types.\n *          The total supply is not encrypted.\n */\nabstract contract ConfidentialERC20 is IConfidentialERC20, IERC20Errors, TFHEErrors {\n    /// @notice Used as a placeholder in `Approval` & `Transfer` events to comply with the official EIP20.\n    uint256 internal constant _PLACEHOLDER = type(uint256).max;\n    /// @notice Total supply.\n    uint64 internal _totalSupply;\n\n    /// @notice Name.\n    string internal _name;\n\n    /// @notice Symbol.\n    string internal _symbol;\n\n    /// @notice A mapping from `account` address to an encrypted `balance`.\n    mapping(address account => euint64 balance) internal _balances;\n\n    /// @notice A mapping of the form mapping(account => mapping(spender => allowance)).\n    mapping(address account => mapping(address spender => euint64 allowance)) internal _allowances;\n\n    /**\n     * @param name_     Name of the token.\n     * @param symbol_   Symbol.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-approve}.\n     */\n    function approve(address spender, einput encryptedAmount, bytes calldata inputProof) public virtual returns (bool) {\n        approve(spender, TFHE.asEuint64(encryptedAmount, inputProof));\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-approve}.\n     */\n    function approve(address spender, euint64 amount) public virtual returns (bool) {\n        _isSenderAllowedForAmount(amount);\n        address owner = msg.sender;\n        _approve(owner, spender, amount);\n        emit Approval(owner, spender, _PLACEHOLDER);\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-transfer}.\n     */\n    function transfer(address to, einput encryptedAmount, bytes calldata inputProof) public virtual returns (bool) {\n        transfer(to, TFHE.asEuint64(encryptedAmount, inputProof));\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-transfer}.\n     */\n    function transfer(address to, euint64 amount) public virtual returns (bool) {\n        _isSenderAllowedForAmount(amount);\n\n        /// @dev Make sure the owner has enough tokens.\n        ebool canTransfer = TFHE.le(amount, _balances[msg.sender]);\n        _transfer(msg.sender, to, amount, canTransfer);\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        einput encryptedAmount,\n        bytes calldata inputProof\n    ) public virtual returns (bool) {\n        transferFrom(from, to, TFHE.asEuint64(encryptedAmount, inputProof));\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-transferFrom}.\n     */\n    function transferFrom(address from, address to, euint64 amount) public virtual returns (bool) {\n        _isSenderAllowedForAmount(amount);\n        address spender = msg.sender;\n        ebool isTransferable = _updateAllowance(from, spender, amount);\n        _transfer(from, to, amount, isTransferable);\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (euint64) {\n        return _allowance(owner, spender);\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (euint64) {\n        return _balances[account];\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-decimals}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 6;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint64) {\n        return _totalSupply;\n    }\n\n    function _approve(address owner, address spender, euint64 amount) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(owner);\n        }\n\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(spender);\n        }\n\n        _allowances[owner][spender] = amount;\n        TFHE.allowThis(amount);\n        TFHE.allow(amount, owner);\n        TFHE.allow(amount, spender);\n    }\n\n    /**\n     * @dev It does not incorporate any overflow check. It must be implemented\n     *      by the function calling it.\n     */\n    function _unsafeMint(address account, uint64 amount) internal virtual {\n        _unsafeMintNoEvent(account, amount);\n        emit Transfer(address(0), account, _PLACEHOLDER);\n    }\n\n    /**\n     * @dev It does not incorporate any overflow check. It must be implemented\n     *      by the function calling it.\n     */\n    function _unsafeMintNoEvent(address account, uint64 amount) internal virtual {\n        euint64 newBalanceAccount = TFHE.add(_balances[account], amount);\n        _balances[account] = newBalanceAccount;\n        TFHE.allowThis(newBalanceAccount);\n        TFHE.allow(newBalanceAccount, account);\n    }\n\n    function _transfer(address from, address to, euint64 amount, ebool isTransferable) internal virtual {\n        _transferNoEvent(from, to, amount, isTransferable);\n        emit Transfer(from, to, _PLACEHOLDER);\n    }\n\n    function _transferNoEvent(address from, address to, euint64 amount, ebool isTransferable) internal virtual {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(from);\n        }\n\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(to);\n        }\n\n        /// @dev Add to the balance of `to` and subtract from the balance of `from`.\n        euint64 transferValue = TFHE.select(isTransferable, amount, TFHE.asEuint64(0));\n        euint64 newBalanceTo = TFHE.add(_balances[to], transferValue);\n        _balances[to] = newBalanceTo;\n        TFHE.allowThis(newBalanceTo);\n        TFHE.allow(newBalanceTo, to);\n        euint64 newBalanceFrom = TFHE.sub(_balances[from], transferValue);\n        _balances[from] = newBalanceFrom;\n        TFHE.allowThis(newBalanceFrom);\n        TFHE.allow(newBalanceFrom, from);\n    }\n\n    function _updateAllowance(address owner, address spender, euint64 amount) internal virtual returns (ebool) {\n        euint64 currentAllowance = _allowance(owner, spender);\n        /// @dev Make sure sure the allowance suffices.\n        ebool allowedTransfer = TFHE.le(amount, currentAllowance);\n        /// @dev Make sure the owner has enough tokens.\n        ebool canTransfer = TFHE.le(amount, _balances[owner]);\n        ebool isTransferable = TFHE.and(canTransfer, allowedTransfer);\n        _approve(owner, spender, TFHE.select(isTransferable, TFHE.sub(currentAllowance, amount), currentAllowance));\n        return isTransferable;\n    }\n\n    function _allowance(address owner, address spender) internal view virtual returns (euint64) {\n        return _allowances[owner][spender];\n    }\n\n    function _isSenderAllowedForAmount(euint64 amount) internal view virtual {\n        if (!TFHE.isSenderAllowed(amount)) {\n            revert TFHESenderNotAllowed();\n        }\n    }\n}\n"
    },
    "fhevm-contracts/contracts/token/ERC20/extensions/ConfidentialERC20WithErrors.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\nimport { ConfidentialERC20 } from \"../ConfidentialERC20.sol\";\nimport { EncryptedErrors } from \"../../../utils/EncryptedErrors.sol\";\n\n/**\n * @title   ConfidentialERC20WithErrors.\n * @notice  This contract implements an encrypted ERC20-like token with confidential balances using\n *          Zama's FHE (Fully Homomorphic Encryption) library.\n * @dev     It supports standard ERC20 functions such as transferring tokens, minting,\n *          and setting allowances, but uses encrypted data types.\n *          The total supply is not encrypted.\n *          It also supports error handling for encrypted errors.\n */\nabstract contract ConfidentialERC20WithErrors is ConfidentialERC20, EncryptedErrors {\n    /**\n     * @notice Error codes allow tracking (in the storage) whether a transfer worked.\n     * @dev    NO_ERROR: the transfer worked as expected.\n     *         UNSUFFICIENT_BALANCE: the transfer failed because the\n     *         from balances were strictly inferior to the amount to transfer.\n     *         UNSUFFICIENT_APPROVAL: the transfer failed because the sender allowance\n     *         was strictly lower than the amount to transfer.\n     */\n    enum ErrorCodes {\n        NO_ERROR,\n        UNSUFFICIENT_BALANCE,\n        UNSUFFICIENT_APPROVAL\n    }\n\n    /**\n     * @param name_     Name of the token.\n     * @param symbol_   Symbol.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_\n    ) ConfidentialERC20(name_, symbol_) EncryptedErrors(uint8(type(ErrorCodes).max)) {}\n\n    /**\n     * @notice See {IConfidentialERC20-transfer}.\n     */\n    function transfer(address to, euint64 amount) public virtual override returns (bool) {\n        _isSenderAllowedForAmount(amount);\n        /// @dev Check whether the owner has enough tokens.\n        ebool canTransfer = TFHE.le(amount, _balances[msg.sender]);\n        euint8 errorCode = _errorDefineIfNot(canTransfer, uint8(ErrorCodes.UNSUFFICIENT_BALANCE));\n        _errorSave(errorCode);\n        TFHE.allow(errorCode, msg.sender);\n        TFHE.allow(errorCode, to);\n        _transfer(msg.sender, to, amount, canTransfer);\n        return true;\n    }\n\n    /**\n     * @notice See {IConfidentialERC20-transferFrom}.\n     */\n    function transferFrom(address from, address to, euint64 amount) public virtual override returns (bool) {\n        _isSenderAllowedForAmount(amount);\n        address spender = msg.sender;\n        ebool isTransferable = _updateAllowance(from, spender, amount);\n        _transfer(from, to, amount, isTransferable);\n        return true;\n    }\n\n    /**\n     * @notice            Return the error for a transfer id.\n     * @param transferId  Transfer id. It can be read from the `Transfer` event.\n     * @return errorCode  Encrypted error code.\n     */\n    function getErrorCodeForTransferId(uint256 transferId) public view virtual returns (euint8 errorCode) {\n        errorCode = _errorGetCodeEmitted(transferId);\n    }\n\n    function _transfer(address from, address to, euint64 amount, ebool isTransferable) internal override {\n        _transferNoEvent(from, to, amount, isTransferable);\n        /// @dev It was incremented in _saveError.\n        emit Transfer(from, to, _errorGetCounter() - 1);\n    }\n\n    function _updateAllowance(\n        address owner,\n        address spender,\n        euint64 amount\n    ) internal virtual override returns (ebool isTransferable) {\n        euint64 currentAllowance = _allowance(owner, spender);\n        /// @dev It checks whether the allowance suffices.\n        ebool allowedTransfer = TFHE.le(amount, currentAllowance);\n        euint8 errorCode = _errorDefineIfNot(allowedTransfer, uint8(ErrorCodes.UNSUFFICIENT_APPROVAL));\n        /// @dev It checks that the owner has enough tokens.\n        ebool canTransfer = TFHE.le(amount, _balances[owner]);\n        ebool isNotTransferableButIsApproved = TFHE.and(TFHE.not(canTransfer), allowedTransfer);\n        errorCode = _errorChangeIf(\n            isNotTransferableButIsApproved,\n            /// @dev Should indeed check that spender is approved to not leak information.\n            ///      on balance of `from` to unauthorized spender via calling reencryptTransferError afterwards.\n            uint8(ErrorCodes.UNSUFFICIENT_BALANCE),\n            errorCode\n        );\n        _errorSave(errorCode);\n        TFHE.allow(errorCode, owner);\n        TFHE.allow(errorCode, spender);\n        isTransferable = TFHE.and(canTransfer, allowedTransfer);\n        _approve(owner, spender, TFHE.select(isTransferable, TFHE.sub(currentAllowance, amount), currentAllowance));\n    }\n}\n"
    },
    "fhevm-contracts/contracts/token/ERC20/extensions/ConfidentialERC20WithErrorsMintable.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\nimport { Ownable2Step, Ownable } from \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport { ConfidentialERC20WithErrors } from \"./ConfidentialERC20WithErrors.sol\";\n\n/**\n * @title   ConfidentialERC20WithErrorsMintable.\n * @notice  This contract inherits ConfidentialERC20WithErrors.\n * @dev     It allows an owner to mint tokens. Mint amounts are public.\n */\nabstract contract ConfidentialERC20WithErrorsMintable is Ownable2Step, ConfidentialERC20WithErrors {\n    /**\n     * @notice Emitted when `amount` tokens are minted to one account (`to`).\n     */\n    event Mint(address indexed to, uint64 amount);\n\n    /**\n     * @param name_     Name of the token.\n     * @param symbol_   Symbol.\n     * @param owner_    Owner address.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address owner_\n    ) Ownable(owner_) ConfidentialERC20WithErrors(name_, symbol_) {}\n\n    /**\n     * @notice       Mint tokens.\n     * @param to     Address to mint tokens to.\n     * @param amount Amount of tokens to mint.\n     */\n    function mint(address to, uint64 amount) public virtual onlyOwner {\n        _unsafeMint(to, amount);\n        /// @dev Since _totalSupply is not encrypted and we ensure there is no underflow/overflow of encrypted balances\n        ///      during transfers, making _totalSupply invariant during transfers, we know _totalSupply is greater than\n        ///      all individual balances. Hence, the next line forbids any overflow to happen in the _unsafeMint above.\n        _totalSupply = _totalSupply + amount;\n        emit Mint(to, amount);\n    }\n}\n"
    },
    "fhevm-contracts/contracts/token/ERC20/IConfidentialERC20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\n\n/**\n * @title   IConfidentialERC20.\n * @notice  Interface that defines ERC20-like tokens with encrypted balances.\n */\ninterface IConfidentialERC20 {\n    /**\n     * @notice              Emitted when the allowance of a `spender` for an `owner` is set by\n     *                      a call to {approve}.\n     * @param owner         Owner address.\n     * @param spender       Spender address.\n     * @param placeholder   Placeholder.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 placeholder);\n\n    /**\n     * @notice              Emitted when tokens are moved from one account (`from`) to\n     *                      another (`to`).\n     * @param from          Sender address.\n     * @param to            Receiver address.\n     * @param transferId    If the implementation does not support error handling, it must be set to a default\n     *                      placeholder (typically equal to max(uint256). However, it must be set to a transferId\n     *                      if the implementation supports encrypted error handling.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 transferId);\n\n    /**\n     * @notice                  Set the `encryptedAmount` as the allowance of `spender` over the caller's tokens.\n     * @param spender           Spender address.\n     * @param encryptedAmount   Encrypted amount.\n     * @param inputProof        Input proof.\n     * @return isSuccess        Whether it succeeds.\n     */\n    function approve(\n        address spender,\n        einput encryptedAmount,\n        bytes calldata inputProof\n    ) external returns (bool isSuccess);\n\n    /**\n     * @notice                  Set the `amount` as the allowance of `spender` over the caller's tokens.\n     * @param spender           Spender address.\n     * @param amount            Encrypted amount.\n     * @return isSuccess        Whether it succeeds.\n     */\n    function approve(address spender, euint64 amount) external returns (bool isSuccess);\n\n    /**\n     * @notice                  Transfer an encrypted amount from the message sender address to the `to` address.\n     * @param to                Receiver address.\n     * @param encryptedAmount   Encrypted amount.\n     * @param inputProof        Input proof.\n     * @return isSuccess        Whether it succeeds.\n     */\n    function transfer(address to, einput encryptedAmount, bytes calldata inputProof) external returns (bool isSuccess);\n\n    /**\n     * @notice              Transfer an amount from the message sender address to the `to` address.\n     * @param to            Receiver address.\n     * @param amount        Encrypted amount.\n     * @return isSuccess    Whether it succeeds.\n     */\n    function transfer(address to, euint64 amount) external returns (bool isSuccess);\n\n    /**\n     * @notice              Transfer `amount` tokens using the caller's allowance.\n     * @param from          Sender address.\n     * @param to            Receiver address.\n     * @param amount        Encrypted amount.\n     * @return isSuccess    Whether it succeeds.\n     */\n    function transferFrom(address from, address to, euint64 amount) external returns (bool isSuccess);\n\n    /**\n     * @notice                  Transfer `encryptedAmount` tokens using the caller's allowance.\n     * @param from              Sender address.\n     * @param to                Receiver address.\n     * @param encryptedAmount   Encrypted amount.\n     * @param inputProof        Input proof.\n     * @return isSuccess        Whether it succeeds.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        einput encryptedAmount,\n        bytes calldata inputProof\n    ) external returns (bool isSuccess);\n\n    /**\n     * @notice              Return the remaining number of tokens that `spender` is allowed to spend\n     *                      on behalf of the `owner`.\n     * @param owner         Owner address.\n     * @param spender       Spender address.\n     * @return allowance    Allowance handle of the spender on behalf of the owner.\n     */\n    function allowance(address owner, address spender) external view returns (euint64 allowance);\n\n    /**\n     * @notice          Return the balance handle of the `account`.\n     * @param account   Account address.\n     * @return balance  Balance handle of the `account`.\n     */\n    function balanceOf(address account) external view returns (euint64 balance);\n\n    /**\n     * @notice          Return the number of decimals.\n     * @return decimals Number of decimals (e.g. 6).\n     */\n    function decimals() external view returns (uint8 decimals);\n\n    /**\n     * @notice          Return the name of the token.\n     * @return name     Name of the token (e.g. \"TestToken\").\n     */\n    function name() external view returns (string memory name);\n\n    /**\n     * @notice          Return the symbol of the token.\n     * @return symbol   Symbol of the token (e.g. \"TEST\").\n     */\n    function symbol() external view returns (string memory symbol);\n\n    /**\n     * @notice              Return the total supply of the token.\n     * @return totalSupply  Total supply of the token.\n     */\n    function totalSupply() external view returns (uint64 totalSupply);\n}\n"
    },
    "fhevm-contracts/contracts/utils/EncryptedErrors.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"fhevm/lib/TFHE.sol\";\n\n/**\n * @title       EncryptedErrors.\n * @notice      This abstract contract is used for error handling in the fhEVM.\n *              Error codes are encrypted in the constructor inside the `_errorCodeDefinitions` mapping.\n * @dev         `_errorCodeDefinitions[0]` should always refer to the `NO_ERROR` code, by default.\n */\nabstract contract EncryptedErrors {\n    /// @notice Returned if the error index is invalid.\n    error ErrorIndexInvalid();\n\n    /// @notice Returned if the error index is null.\n    error ErrorIndexIsNull();\n\n    /// @notice Returned if the total number of errors is equal to zero.\n    error TotalNumberErrorCodesEqualToZero();\n\n    /// @notice Total number of error codes.\n    /// @dev    Should hold the constant size of the `_errorCodeDefinitions` mapping.\n    uint8 private immutable _TOTAL_NUMBER_ERROR_CODES;\n\n    /// @notice Used to keep track of number of emitted errors.\n    /// @dev Should hold the size of the _errorCodesEmitted mapping.\n    uint256 private _errorCounter;\n\n    /// @notice Mapping of trivially encrypted error codes definitions.\n    /// @dev In storage because solc does not support immutable mapping, neither immutable arrays, yet.\n    mapping(uint8 errorCode => euint8 encryptedErrorCode) private _errorCodeDefinitions;\n\n    /// @notice Mapping of encrypted error codes emitted.\n    mapping(uint256 errorIndex => euint8 encryptedErrorCode) private _errorCodesEmitted;\n\n    /**\n     * @notice                       Sets the non-null value for `_TOTAL_NUMBER_ERROR_CODES`\n     *                               corresponding to the total number of errors.\n     * @param totalNumberErrorCodes_ Total number of different errors.\n     * @dev                          `totalNumberErrorCodes_` must be non-null\n     *                               (`_errorCodeDefinitions[0]` corresponds to the `NO_ERROR` code).\n     */\n    constructor(uint8 totalNumberErrorCodes_) {\n        if (totalNumberErrorCodes_ == 0) {\n            revert TotalNumberErrorCodesEqualToZero();\n        }\n\n        for (uint8 i; i <= totalNumberErrorCodes_; i++) {\n            euint8 errorCode = TFHE.asEuint8(i);\n            _errorCodeDefinitions[i] = errorCode;\n            TFHE.allowThis(errorCode);\n        }\n\n        _TOTAL_NUMBER_ERROR_CODES = totalNumberErrorCodes_;\n    }\n\n    /**\n     * @notice                  Computes an encrypted error code, result will be either a reencryption of\n     *                          `_errorCodeDefinitions[indexCode]` if `condition` is an encrypted `true`\n     *                          or of `errorCode` otherwise.\n     * @param condition         Encrypted boolean used in the select operator.\n     * @param errorCode         Selected error code if `condition` encrypts `true`.\n     * @return newErrorCode     New reencrypted error code depending on `condition` value.\n     * @dev                 `   indexCode` must be below the total number of error codes.\n     */\n    function _errorChangeIf(\n        ebool condition,\n        uint8 indexCode,\n        euint8 errorCode\n    ) internal virtual returns (euint8 newErrorCode) {\n        if (indexCode > _TOTAL_NUMBER_ERROR_CODES) {\n            revert ErrorIndexInvalid();\n        }\n\n        newErrorCode = TFHE.select(condition, _errorCodeDefinitions[indexCode], errorCode);\n    }\n\n    /**\n     * @notice                  Does the opposite of `changeErrorIf`, i.e result will be either a reencryption of\n     *                          `_errorCodeDefinitions[indexCode]` if `condition` is an encrypted `false`\n     *                          or of `errorCode` otherwise.\n     * @param condition         The encrypted boolean used in the `TFHE.select`.\n     * @param errorCode         The selected error code if `condition` encrypts `false`.\n     * @return newErrorCode     New error code depending on `condition` value.\n     * @dev                     `indexCode` must be below the total number of error codes.\n     */\n    function _errorChangeIfNot(\n        ebool condition,\n        uint8 indexCode,\n        euint8 errorCode\n    ) internal virtual returns (euint8 newErrorCode) {\n        if (indexCode > _TOTAL_NUMBER_ERROR_CODES) {\n            revert ErrorIndexInvalid();\n        }\n\n        newErrorCode = TFHE.select(condition, errorCode, _errorCodeDefinitions[indexCode]);\n    }\n\n    /**\n     * @notice              Computes an encrypted error code, result will be either a reencryption of\n     *                      `_errorCodeDefinitions[indexCode]` if `condition` is an encrypted `true`\n     *                      or of `NO_ERROR` otherwise.\n     * @param condition     Encrypted boolean used in the select operator.\n     * @param indexCode     Index of the selected error code if `condition` encrypts `true`.\n     * @return errorCode    Reencrypted error code depending on `condition` value.\n     * @dev                 `indexCode` must be non-null and below the total number of defined error codes.\n     */\n    function _errorDefineIf(ebool condition, uint8 indexCode) internal virtual returns (euint8 errorCode) {\n        if (indexCode == 0) {\n            revert ErrorIndexIsNull();\n        }\n\n        if (indexCode > _TOTAL_NUMBER_ERROR_CODES) {\n            revert ErrorIndexInvalid();\n        }\n\n        errorCode = TFHE.select(condition, _errorCodeDefinitions[indexCode], _errorCodeDefinitions[0]);\n    }\n\n    /**\n     * @notice                Does the opposite of `defineErrorIf`, i.e result will be either a reencryption of\n     *                        `_errorCodeDefinitions[indexCode]` if `condition` is an encrypted `false` or\n     *                        of `NO_ERROR` otherwise.\n     * @param condition       Encrypted boolean used in the select operator.\n     * @param indexCode       Index of the selected error code if `condition` encrypts `false`.\n     * @return errorCode      Reencrypted error code depending on `condition` value.\n     * @dev                   `indexCode` must be non-null and below the total number of defined error codes.\n     */\n    function _errorDefineIfNot(ebool condition, uint8 indexCode) internal virtual returns (euint8 errorCode) {\n        if (indexCode == 0) {\n            revert ErrorIndexIsNull();\n        }\n\n        if (indexCode > _TOTAL_NUMBER_ERROR_CODES) {\n            revert ErrorIndexInvalid();\n        }\n\n        errorCode = TFHE.select(condition, _errorCodeDefinitions[0], _errorCodeDefinitions[indexCode]);\n    }\n\n    /**\n     * @notice                  Saves `errorCode` in storage, in the `_errorCodesEmitted` mapping.\n     * @param errorCode         Encrypted error code to be saved in storage.\n     * @return errorId          The `errorId` key in `_errorCodesEmitted` where `errorCode` is stored.\n     */\n    function _errorSave(euint8 errorCode) internal virtual returns (uint256 errorId) {\n        errorId = _errorCounter;\n        _errorCounter++;\n        _errorCodesEmitted[errorId] = errorCode;\n\n        TFHE.allowThis(errorCode);\n    }\n\n    /**\n     * @notice                     Returns the trivially encrypted error code at index `indexCodeDefinition`.\n     * @param indexCodeDefinition  Index of the requested error code definition.\n     * @return errorCode           Encrypted error code located at `indexCodeDefinition` in `_errorCodeDefinitions`.\n     */\n    function _errorGetCodeDefinition(uint8 indexCodeDefinition) internal view virtual returns (euint8 errorCode) {\n        if (indexCodeDefinition >= _TOTAL_NUMBER_ERROR_CODES) {\n            revert ErrorIndexInvalid();\n        }\n\n        errorCode = _errorCodeDefinitions[indexCodeDefinition];\n    }\n\n    /**\n     * @notice                  Returns the encrypted error code which was stored in `_errorCodesEmitted`\n     *                          at key `errorId`.\n     * @param errorId           Requested key stored in the `_errorCodesEmitted` mapping.\n     * @return errorCode        Encrypted error code located at the `errorId` key.\n     * @dev                     `errorId` must be a valid id, i.e below the error counter.\n     */\n    function _errorGetCodeEmitted(uint256 errorId) internal view virtual returns (euint8 errorCode) {\n        if (errorId >= _errorCounter) {\n            revert ErrorIndexInvalid();\n        }\n\n        errorCode = _errorCodesEmitted[errorId];\n    }\n\n    /**\n     * @notice             Returns the total counter of emitted of error codes.\n     * @return countErrors Number of errors emitted.\n     */\n    function _errorGetCounter() internal view virtual returns (uint256 countErrors) {\n        countErrors = _errorCounter;\n    }\n\n    /**\n     * @notice                       Returns the total number of the possible error codes defined.\n     * @return totalNumberErrorCodes Total number of the different possible error codes.\n     */\n    function _errorGetNumCodesDefined() internal view virtual returns (uint8 totalNumberErrorCodes) {\n        totalNumberErrorCodes = _TOTAL_NUMBER_ERROR_CODES;\n    }\n}\n"
    },
    "fhevm-contracts/contracts/utils/TFHEErrors.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\ninterface TFHEErrors {\n    /**\n     * @notice Returned when the `sender` is not allowed to access a value.\n     */\n    error TFHESenderNotAllowed();\n}\n"
    },
    "fhevm/config/ZamaFHEVMConfig.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {TFHE} from \"../lib/TFHE.sol\";\nimport {FHEVMConfigStruct} from \"../lib/Impl.sol\";\n\n/**\n * @title   ZamaFHEVMConfig.\n * @notice  This library returns the TFHE config for different networks\n *          with the contract addresses for\n *          (1) ACL, (2) TFHEExecutor, (3) FHEPayment, (4) KMSVerifier,\n *          which are deployed & maintained by Zama.\n */\nlibrary ZamaFHEVMConfig {\n    function getSepoliaConfig() internal pure returns (FHEVMConfigStruct memory) {\n        return\n            FHEVMConfigStruct({\n                ACLAddress: 0xFee8407e2f5e3Ee68ad77cAE98c434e637f516e5,\n                TFHEExecutorAddress: 0x687408aB54661ba0b4aeF3a44156c616c6955E07,\n                FHEPaymentAddress: 0xFb03BE574d14C256D56F09a198B586bdfc0A9de2,\n                KMSVerifierAddress: 0x9D6891A6240D6130c54ae243d8005063D05fE14b\n            });\n    }\n\n    function getEthereumConfig() internal pure returns (FHEVMConfigStruct memory) {\n        /// TODO\n    }\n}\n\n/**\n * @title   SepoliaZamaFHEVMConfig.\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\n *          on the Sepolia network (chainId = 11155111).\n *          Other providers may offer similar contracts deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract SepoliaZamaFHEVMConfig {\n    constructor() {\n        TFHE.setFHEVM(ZamaFHEVMConfig.getSepoliaConfig());\n    }\n}\n\n/**\n * @title   EthereumZamaFHEVMConfig.\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\n *          on the Ethereum (mainnet) network (chainId = 1).\n *          Other providers may offer similar contracts deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract EthereumZamaFHEVMConfig {\n    constructor() {\n        TFHE.setFHEVM(ZamaFHEVMConfig.getEthereumConfig());\n    }\n}\n"
    },
    "fhevm/config/ZamaGatewayConfig.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport {Gateway} from \"../gateway/lib/Gateway.sol\";\n\n/**\n * @title   ZamaGatewayConfig.\n * @notice  This library returns the Gateway config for different networks\n *          with the address of the Gateway contract, which is\n *          deployed & maintained by Zama.\n */\nlibrary ZamaGatewayConfig {\n    function getSepoliaConfig() internal pure returns (address) {\n        return 0x33347831500F1e73f0ccCBb95c9f86B94d7b1123;\n    }\n\n    function getEthereumConfig() internal pure returns (address) {\n        /// TODO\n    }\n}\n\n/**\n * @title   SepoliaZamaGatewayConfig\n * @dev     This contract can be inherited by a contract wishing to use the Gateway service\n *          provided by Zama on the Sepolia network (chainId = 11155111).\n *          Other providers may offer other Gateways that are deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract SepoliaZamaGatewayConfig {\n    constructor() {\n        Gateway.setGateway(ZamaGatewayConfig.getSepoliaConfig());\n    }\n}\n\n/**\n * @title   EthereumZamaGatewayConfig\n * @dev     This contract can be inherited by a contract wishing to use the Gateway service\n *          provided by Zama on the Ethereum (mainnet) network (chainId = 1).\n *          Other providers may offer other Gateways that are deployed at different addresses.\n *          If you wish to use them, you should rely on the instructions from these providers.\n */\ncontract EthereumZamaGatewayConfig {\n    constructor() {\n        Gateway.setGateway(ZamaGatewayConfig.getEthereumConfig());\n    }\n}\n"
    },
    "fhevm/gateway/GatewayCaller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.24;\n\nimport \"../lib/TFHE.sol\";\nimport \"./lib/Gateway.sol\";\n\nabstract contract GatewayCaller {\n    modifier onlyGateway() {\n        require(msg.sender == Gateway.gatewayContractAddress());\n        _;\n    }\n    mapping(uint256 => ebool[]) private paramsEBool;\n    mapping(uint256 => euint4[]) private paramsEUint4;\n    mapping(uint256 => euint8[]) private paramsEUint8;\n    mapping(uint256 => euint16[]) private paramsEUint16;\n    mapping(uint256 => euint32[]) private paramsEUint32;\n    mapping(uint256 => euint64[]) private paramsEUint64;\n    mapping(uint256 => eaddress[]) private paramsEAddress;\n    mapping(uint256 => address[]) private paramsAddress;\n    mapping(uint256 => uint256[]) private paramsUint256;\n    mapping(uint256 => uint256[]) private requestedHandles;\n\n    constructor() {}\n\n    function addParamsEBool(uint256 requestID, ebool _ebool) internal {\n        paramsEBool[requestID].push(_ebool);\n    }\n\n    function addParamsEUint4(uint256 requestID, euint4 _euint4) internal {\n        paramsEUint4[requestID].push(_euint4);\n    }\n\n    function addParamsEUint8(uint256 requestID, euint8 _euint8) internal {\n        paramsEUint8[requestID].push(_euint8);\n    }\n\n    function addParamsEUint16(uint256 requestID, euint16 _euint16) internal {\n        paramsEUint16[requestID].push(_euint16);\n    }\n\n    function addParamsEUint32(uint256 requestID, euint32 _euint32) internal {\n        paramsEUint32[requestID].push(_euint32);\n    }\n\n    function addParamsEUint64(uint256 requestID, euint64 _euint64) internal {\n        paramsEUint64[requestID].push(_euint64);\n    }\n\n    function addParamsEAddress(uint256 requestID, eaddress _eaddress) internal {\n        paramsEAddress[requestID].push(_eaddress);\n    }\n\n    function addParamsAddress(uint256 requestID, address _address) internal {\n        paramsAddress[requestID].push(_address);\n    }\n\n    function addParamsUint256(uint256 requestID, uint256 _uint) internal {\n        paramsUint256[requestID].push(_uint);\n    }\n\n    function saveRequestedHandles(uint256 requestID, uint256[] memory handlesList) internal {\n        require(requestedHandles[requestID].length == 0, \"requested handles already saved\");\n        requestedHandles[requestID] = handlesList;\n    }\n\n    function loadRequestedHandles(uint256 requestID) internal view returns (uint256[] memory) {\n        require(requestedHandles[requestID].length != 0, \"requested handles were not saved for this requestID\");\n        return requestedHandles[requestID];\n    }\n\n    function getParamsEBool(uint256 requestID) internal view returns (ebool[] memory) {\n        return paramsEBool[requestID];\n    }\n\n    function getParamsEUint4(uint256 requestID) internal view returns (euint4[] memory) {\n        return paramsEUint4[requestID];\n    }\n\n    function getParamsEUint8(uint256 requestID) internal view returns (euint8[] memory) {\n        return paramsEUint8[requestID];\n    }\n\n    function getParamsEUint16(uint256 requestID) internal view returns (euint16[] memory) {\n        return paramsEUint16[requestID];\n    }\n\n    function getParamsEUint32(uint256 requestID) internal view returns (euint32[] memory) {\n        return paramsEUint32[requestID];\n    }\n\n    function getParamsEUint64(uint256 requestID) internal view returns (euint64[] memory) {\n        return paramsEUint64[requestID];\n    }\n\n    function getParamsEAddress(uint256 requestID) internal view returns (eaddress[] memory) {\n        return paramsEAddress[requestID];\n    }\n\n    function getParamsAddress(uint256 requestID) internal view returns (address[] memory) {\n        return paramsAddress[requestID];\n    }\n\n    function getParamsUint256(uint256 requestID) internal view returns (uint256[] memory) {\n        return paramsUint256[requestID];\n    }\n}\n"
    },
    "fhevm/gateway/lib/Gateway.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\n\npragma solidity ^0.8.24;\n\nimport \"../../lib/Impl.sol\";\n\ninterface IKMSVerifier {\n    function verifyDecryptionEIP712KMSSignatures(\n        address aclAddress,\n        uint256[] memory handlesList,\n        bytes memory decryptedResult,\n        bytes[] memory signatures\n    ) external returns (bool);\n}\n\ninterface IGatewayContract {\n    function requestDecryption(\n        uint256[] calldata ctsHandles,\n        bytes4 callbackSelector,\n        uint256 msgValue,\n        uint256 maxTimestamp,\n        bool passSignaturesToCaller\n    ) external returns (uint256);\n}\n\nstruct GatewayConfigStruct {\n    address GatewayContractAddress;\n}\n\nlibrary Gateway {\n    // keccak256(abi.encode(uint256(keccak256(\"fhevm.storage.GatewayConfig\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant GatewayLocation = 0x93ab6e17f2c461cce6ea5d4ec117e51dda77a64affc2b2c05f8cd440def0e700;\n\n    function getGetwayConfig() internal pure returns (GatewayConfigStruct storage $) {\n        assembly {\n            $.slot := GatewayLocation\n        }\n    }\n\n    function setGateway(address gatewayAddress) internal {\n        GatewayConfigStruct storage $ = getGetwayConfig();\n        $.GatewayContractAddress = gatewayAddress;\n    }\n\n    function gatewayContractAddress() internal view returns (address) {\n        GatewayConfigStruct storage $ = getGetwayConfig();\n        return $.GatewayContractAddress;\n    }\n\n    function toUint256(ebool newCT) internal pure returns (uint256 ct) {\n        ct = ebool.unwrap(newCT);\n    }\n\n    function toUint256(euint4 newCT) internal pure returns (uint256 ct) {\n        ct = euint4.unwrap(newCT);\n    }\n\n    function toUint256(euint8 newCT) internal pure returns (uint256 ct) {\n        ct = euint8.unwrap(newCT);\n    }\n\n    function toUint256(euint16 newCT) internal pure returns (uint256 ct) {\n        ct = euint16.unwrap(newCT);\n    }\n\n    function toUint256(euint32 newCT) internal pure returns (uint256 ct) {\n        ct = euint32.unwrap(newCT);\n    }\n\n    function toUint256(euint64 newCT) internal pure returns (uint256 ct) {\n        ct = euint64.unwrap(newCT);\n    }\n\n    function toUint256(euint128 newCT) internal pure returns (uint256 ct) {\n        ct = euint128.unwrap(newCT);\n    }\n\n    function toUint256(eaddress newCT) internal pure returns (uint256 ct) {\n        ct = eaddress.unwrap(newCT);\n    }\n\n    function toUint256(euint256 newCT) internal pure returns (uint256 ct) {\n        ct = euint256.unwrap(newCT);\n    }\n\n    function toUint256(ebytes64 newCT) internal pure returns (uint256 ct) {\n        ct = ebytes64.unwrap(newCT);\n    }\n\n    function toUint256(ebytes128 newCT) internal pure returns (uint256 ct) {\n        ct = ebytes128.unwrap(newCT);\n    }\n\n    function toUint256(ebytes256 newCT) internal pure returns (uint256 ct) {\n        ct = ebytes256.unwrap(newCT);\n    }\n\n    function requestDecryption(\n        uint256[] memory ctsHandles,\n        bytes4 callbackSelector,\n        uint256 msgValue,\n        uint256 maxTimestamp,\n        bool passSignaturesToCaller\n    ) internal returns (uint256 requestID) {\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\n        IACL($.ACLAddress).allowForDecryption(ctsHandles);\n        GatewayConfigStruct storage $$ = getGetwayConfig();\n        requestID = IGatewayContract($$.GatewayContractAddress).requestDecryption(\n            ctsHandles,\n            callbackSelector,\n            msgValue,\n            maxTimestamp,\n            passSignaturesToCaller\n        );\n    }\n\n    /// @dev this function is supposed to be called inside the callback function if the dev wants the dApp contract to verify the signatures\n    /// @dev this is useful to give dev the choice not to rely on trusting the GatewayContract.\n    /// @notice this could be used only when signatures are made available to the callback, i.e when `passSignaturesToCaller` is set to true during request\n    function verifySignatures(uint256[] memory handlesList, bytes[] memory signatures) internal returns (bool) {\n        uint256 start = 4 + 32; // start position after skipping the selector (4 bytes) and the first argument (index, 32 bytes)\n        uint256 length = getSignedDataLength(handlesList);\n        bytes memory decryptedResult = new bytes(length);\n        assembly {\n            calldatacopy(add(decryptedResult, 0x20), start, length) // Copy the relevant part of calldata to decryptedResult memory\n        }\n        decryptedResult = shiftOffsets(decryptedResult, handlesList);\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\n        return\n            IKMSVerifier($.KMSVerifierAddress).verifyDecryptionEIP712KMSSignatures(\n                $.ACLAddress,\n                handlesList,\n                decryptedResult,\n                signatures\n            );\n    }\n\n    function getSignedDataLength(uint256[] memory handlesList) private pure returns (uint256) {\n        uint256 handlesListlen = handlesList.length;\n        uint256 signedDataLength;\n        for (uint256 i = 0; i < handlesListlen; i++) {\n            uint8 typeCt = uint8(handlesList[i] >> 8);\n            if (typeCt < 9) {\n                signedDataLength += 32;\n            } else if (typeCt == 9) {\n                //ebytes64\n                signedDataLength += 128;\n            } else if (typeCt == 10) {\n                //ebytes128\n                signedDataLength += 192;\n            } else if (typeCt == 11) {\n                //ebytes256\n                signedDataLength += 320;\n            } else {\n                revert(\"Unsupported handle type\");\n            }\n        }\n        signedDataLength += 32; // add offset of signatures\n        return signedDataLength;\n    }\n\n    function shiftOffsets(bytes memory input, uint256[] memory handlesList) private pure returns (bytes memory) {\n        uint256 numArgs = handlesList.length;\n        for (uint256 i = 0; i < numArgs; i++) {\n            uint8 typeCt = uint8(handlesList[i] >> 8);\n            if (typeCt >= 9) {\n                input = subToBytes32Slice(input, 32 * i); // because we append the signatures, all bytes offsets are shifted by 0x20\n            }\n        }\n        input = remove32Slice(input, 32 * numArgs);\n        return input;\n    }\n\n    function subToBytes32Slice(bytes memory data, uint256 offset) private pure returns (bytes memory) {\n        // @note: data is assumed to be more than 32+offset bytes long\n        assembly {\n            let ptr := add(add(data, 0x20), offset)\n            let val := mload(ptr)\n            val := sub(val, 0x20)\n            mstore(ptr, val)\n        }\n        return data;\n    }\n\n    function remove32Slice(bytes memory input, uint256 start) private pure returns (bytes memory) {\n        // @note we assume start+32 is less than input.length\n        bytes memory result = new bytes(input.length - 32);\n\n        for (uint256 i = 0; i < start; i++) {\n            result[i] = input[i];\n        }\n\n        for (uint256 i = start + 32; i < input.length; i++) {\n            result[i - 32] = input[i];\n        }\n\n        return result;\n    }\n}\n"
    },
    "fhevm/lib/Impl.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"./TFHE.sol\";\n\n/**\n * @title   FHEVMConfigStruct\n * @notice  This struct contains all addresses of core contrats which are needed in a typical dApp.\n */\nstruct FHEVMConfigStruct {\n    address ACLAddress;\n    address TFHEExecutorAddress;\n    address FHEPaymentAddress;\n    address KMSVerifierAddress;\n}\n\n/**\n * @title   ITFHEExecutor\n * @notice  This interface contains all functions to conduct FHE operations.\n */\ninterface ITFHEExecutor {\n    function fheAdd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheSub(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheMul(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheDiv(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheRem(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheBitAnd(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheBitOr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheBitXor(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheShl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheShr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheRotl(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheRotr(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheEq(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheNe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheGe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheGt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheLe(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheLt(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheMin(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheMax(uint256 lhs, uint256 rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheNeg(uint256 ct) external returns (uint256 result);\n    function fheNot(uint256 ct) external returns (uint256 result);\n    function verifyCiphertext(\n        bytes32 inputHandle,\n        address callerAddress,\n        bytes memory inputProof,\n        bytes1 inputType\n    ) external returns (uint256 result);\n    function cast(uint256 ct, bytes1 toType) external returns (uint256 result);\n    function trivialEncrypt(uint256 ct, bytes1 toType) external returns (uint256 result);\n    function trivialEncrypt(bytes memory ct, bytes1 toType) external returns (uint256 result);\n    function fheEq(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheNe(uint256 lhs, bytes memory rhs, bytes1 scalarByte) external returns (uint256 result);\n    function fheIfThenElse(uint256 control, uint256 ifTrue, uint256 ifFalse) external returns (uint256 result);\n    function fheRand(bytes1 randType) external returns (uint256 result);\n    function fheRandBounded(uint256 upperBound, bytes1 randType) external returns (uint256 result);\n}\n\n/**\n * @title   IACL\n * @notice  This interface contains all functions that are used to conduct operations\n *          with the ACL contract.\n */\ninterface IACL {\n    function allowTransient(uint256 ciphertext, address account) external;\n    function allow(uint256 handle, address account) external;\n    function cleanTransientStorage() external;\n    function isAllowed(uint256 handle, address account) external view returns (bool);\n    function allowForDecryption(uint256[] memory handlesList) external;\n}\n\n/**\n * @title   Impl\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\n */\nlibrary Impl {\n    /// @dev keccak256(abi.encode(uint256(keccak256(\"fhevm.storage.FHEVMConfig\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\n\n    function getFHEVMConfig() internal pure returns (FHEVMConfigStruct storage $) {\n        assembly {\n            $.slot := FHEVMConfigLocation\n        }\n    }\n\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        $.ACLAddress = fhevmConfig.ACLAddress;\n        $.TFHEExecutorAddress = fhevmConfig.TFHEExecutorAddress;\n        $.FHEPaymentAddress = fhevmConfig.FHEPaymentAddress;\n        $.KMSVerifierAddress = fhevmConfig.KMSVerifierAddress;\n    }\n\n    function add(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheAdd(lhs, rhs, scalarByte);\n    }\n\n    function sub(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheSub(lhs, rhs, scalarByte);\n    }\n\n    function mul(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMul(lhs, rhs, scalarByte);\n    }\n\n    function div(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\n        bytes1 scalarByte = 0x01;\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheDiv(lhs, rhs, scalarByte);\n    }\n\n    function rem(uint256 lhs, uint256 rhs) internal returns (uint256 result) {\n        bytes1 scalarByte = 0x01;\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRem(lhs, rhs, scalarByte);\n    }\n\n    function and(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitAnd(lhs, rhs, scalarByte);\n    }\n\n    function or(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitOr(lhs, rhs, scalarByte);\n    }\n\n    function xor(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheBitXor(lhs, rhs, scalarByte);\n    }\n\n    function shl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShl(lhs, rhs, scalarByte);\n    }\n\n    function shr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheShr(lhs, rhs, scalarByte);\n    }\n\n    function rotl(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotl(lhs, rhs, scalarByte);\n    }\n\n    function rotr(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRotr(lhs, rhs, scalarByte);\n    }\n\n    function eq(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\n    }\n\n    function ne(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\n    }\n\n    function ge(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGe(lhs, rhs, scalarByte);\n    }\n\n    function gt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheGt(lhs, rhs, scalarByte);\n    }\n\n    function le(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLe(lhs, rhs, scalarByte);\n    }\n\n    function lt(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheLt(lhs, rhs, scalarByte);\n    }\n\n    function min(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMin(lhs, rhs, scalarByte);\n    }\n\n    function max(uint256 lhs, uint256 rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheMax(lhs, rhs, scalarByte);\n    }\n\n    function neg(uint256 ct) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNeg(ct);\n    }\n\n    function not(uint256 ct) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNot(ct);\n    }\n\n    // If 'control's value is 'true', the result has the same value as 'ifTrue'.\n    // If 'control's value is 'false', the result has the same value as 'ifFalse'.\n    function select(uint256 control, uint256 ifTrue, uint256 ifFalse) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheIfThenElse(control, ifTrue, ifFalse);\n    }\n\n    function verify(bytes32 inputHandle, bytes memory inputProof, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).verifyCiphertext(\n            inputHandle,\n            msg.sender,\n            inputProof,\n            bytes1(toType)\n        );\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\n    }\n\n    function cast(uint256 ciphertext, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).cast(ciphertext, bytes1(toType));\n    }\n\n    function trivialEncrypt(uint256 value, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\n    }\n\n    function trivialEncrypt(bytes memory value, uint8 toType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).trivialEncrypt(value, bytes1(toType));\n    }\n\n    function eq(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheEq(lhs, rhs, scalarByte);\n    }\n\n    function ne(uint256 lhs, bytes memory rhs, bool scalar) internal returns (uint256 result) {\n        bytes1 scalarByte;\n        if (scalar) {\n            scalarByte = 0x01;\n        } else {\n            scalarByte = 0x00;\n        }\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheNe(lhs, rhs, scalarByte);\n    }\n\n    function rand(uint8 randType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRand(bytes1(randType));\n    }\n\n    function randBounded(uint256 upperBound, uint8 randType) internal returns (uint256 result) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        result = ITFHEExecutor($.TFHEExecutorAddress).fheRandBounded(upperBound, bytes1(randType));\n    }\n\n    function allowTransient(uint256 handle, address account) internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        IACL($.ACLAddress).allowTransient(handle, account);\n    }\n\n    function allow(uint256 handle, address account) internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        IACL($.ACLAddress).allow(handle, account);\n    }\n\n    function cleanTransientStorage() internal {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        IACL($.ACLAddress).cleanTransientStorage();\n    }\n\n    function isAllowed(uint256 handle, address account) internal view returns (bool) {\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\n        return IACL($.ACLAddress).isAllowed(handle, account);\n    }\n}\n"
    },
    "fhevm/lib/TFHE.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause-Clear\npragma solidity ^0.8.24;\n\nimport \"./Impl.sol\";\n\ntype ebool is uint256;\ntype euint4 is uint256;\ntype euint8 is uint256;\ntype euint16 is uint256;\ntype euint32 is uint256;\ntype euint64 is uint256;\ntype euint128 is uint256;\ntype euint256 is uint256;\ntype eaddress is uint256;\ntype ebytes64 is uint256;\ntype ebytes128 is uint256;\ntype ebytes256 is uint256;\ntype einput is bytes32;\n\n/**\n * @title   Common\n * @notice  This library contains all the values used to communicate types to the run time.\n */\nlibrary Common {\n    uint8 internal constant ebool_t = 0;\n    uint8 internal constant euint4_t = 1;\n    uint8 internal constant euint8_t = 2;\n    uint8 internal constant euint16_t = 3;\n    uint8 internal constant euint32_t = 4;\n    uint8 internal constant euint64_t = 5;\n    uint8 internal constant euint128_t = 6;\n    uint8 internal constant euint160_t = 7;\n    uint8 internal constant euint256_t = 8;\n    uint8 internal constant ebytes64_t = 9;\n    uint8 internal constant ebytes128_t = 10;\n    uint8 internal constant ebytes256_t = 11;\n}\n\n/**\n * @title   TFHE\n * @notice  This library is the interaction point for all smart contract developers\n *          that interact with TFHE.\n */\nlibrary TFHE {\n    function setFHEVM(FHEVMConfigStruct memory fhevmConfig) internal {\n        Impl.setFHEVM(fhevmConfig);\n    }\n\n    // Return true if the enrypted bool is initialized and false otherwise.\n    function isInitialized(ebool v) internal pure returns (bool) {\n        return ebool.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint4 v) internal pure returns (bool) {\n        return euint4.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint8 v) internal pure returns (bool) {\n        return euint8.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint16 v) internal pure returns (bool) {\n        return euint16.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint32 v) internal pure returns (bool) {\n        return euint32.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint64 v) internal pure returns (bool) {\n        return euint64.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint128 v) internal pure returns (bool) {\n        return euint128.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted integer is initialized and false otherwise.\n    function isInitialized(euint256 v) internal pure returns (bool) {\n        return euint256.unwrap(v) != 0;\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.add(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.and(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.or(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.min(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.max(euint4.unwrap(a), euint4.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(asEuint8(a)), euint8.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.add(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.add(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.sub(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint8 a, euint4 b) internal returns (euint4) {\n        euint4 aEnc = asEuint4(a);\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.sub(euint4.unwrap(aEnc), euint4.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.mul(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.mul(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.div(euint4.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.rem(euint4.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.and(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.and(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.or(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.or(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.xor(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.xor(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint4 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.min(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.min(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.max(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint8 a, euint4 b) internal returns (euint4) {\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint4.wrap(Impl.max(euint4.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint4 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(asEuint8(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.add(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\n        euint8 aEnc = asEuint8(a);\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.div(euint8.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.and(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.or(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.min(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.max(euint8.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint4 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.add(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\n        euint16 aEnc = asEuint16(a);\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.div(euint16.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.and(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.or(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.min(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint16 a, uint16 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint16 a, euint16 b) internal returns (euint16) {\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint16.wrap(Impl.max(euint16.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint4 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint16 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.add(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\n        euint32 aEnc = asEuint32(a);\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.div(euint32.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.and(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.or(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.min(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint32 a, uint32 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint32 a, euint32 b) internal returns (euint32) {\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint32.wrap(Impl.max(euint32.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint4 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint16 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint32 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.add(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\n        euint64 aEnc = asEuint64(a);\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.div(euint64.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.and(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.or(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.min(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint64 a, uint64 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint64 a, euint64 b) internal returns (euint64) {\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint64.wrap(Impl.max(euint64.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint4 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint16 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint32 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint64 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.add(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\n        euint128 aEnc = asEuint128(a);\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.div(euint128.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.and(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.or(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.min(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint128 a, uint128 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint128 a, euint128 b) internal returns (euint128) {\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint128.wrap(Impl.max(euint128.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint4 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint4 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint4(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint8 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint16 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint16 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint16(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint32 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint32 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint32(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint64 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint64(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint128 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint128(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), euint256.unwrap(b), false));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate add(a, b) and return the result.\n    function add(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.add(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate sub(a, b) and return the result.\n    function sub(uint256 a, euint256 b) internal returns (euint256) {\n        euint256 aEnc = asEuint256(a);\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.sub(euint256.unwrap(aEnc), euint256.unwrap(b), false));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate mul(a, b) and return the result.\n    function mul(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.mul(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate div(a, b) and return the result.\n    function div(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.div(euint256.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate rem(a, b) and return the result.\n    function rem(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rem(euint256.unwrap(a), uint256(b)));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.and(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.or(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate ge(a, b) and return the result.\n    function ge(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate gt(a, b) and return the result.\n    function gt(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.le(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate le(a, b) and return the result.\n    function le(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.ge(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(euint256 a, uint256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return ebool.wrap(Impl.lt(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate lt(a, b) and return the result.\n    function lt(uint256 a, euint256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return ebool.wrap(Impl.gt(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate min(a, b) and return the result.\n    function min(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.min(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(euint256 a, uint256 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate max(a, b) and return the result.\n    function max(uint256 a, euint256 b) internal returns (euint256) {\n        if (!isInitialized(b)) {\n            b = asEuint256(0);\n        }\n        return euint256.wrap(Impl.max(euint256.unwrap(b), uint256(a), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.shl(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.shr(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.rotl(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint4 a, uint8 b) internal returns (euint4) {\n        if (!isInitialized(a)) {\n            a = asEuint4(0);\n        }\n        return euint4.wrap(Impl.rotr(euint4.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\n        if (!isInitialized(a)) {\n            a = asEuint8(0);\n        }\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\n        if (!isInitialized(a)) {\n            a = asEuint16(0);\n        }\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\n        if (!isInitialized(a)) {\n            a = asEuint32(0);\n        }\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\n        if (!isInitialized(a)) {\n            a = asEuint64(0);\n        }\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\n        if (!isInitialized(a)) {\n            a = asEuint128(0);\n        }\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate shl(a, b) and return the result.\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate shr(a, b) and return the result.\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate rotl(a, b) and return the result.\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        if (!isInitialized(b)) {\n            b = asEuint8(0);\n        }\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\n    }\n\n    // Evaluate rotr(a, b) and return the result.\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\n        if (!isInitialized(a)) {\n            a = asEuint256(0);\n        }\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), uint256(b), true));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint4 a, euint4 b) internal returns (euint4) {\n        return euint4.wrap(Impl.select(ebool.unwrap(control), euint4.unwrap(a), euint4.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\n    }\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\n    }\n    // Cast an encrypted integer from euint8 to euint4.\n    function asEuint4(euint8 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint8.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint4.\n    function asEuint4(euint16 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint16.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint4.\n    function asEuint4(euint32 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint32.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint4.\n    function asEuint4(euint64 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint64.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint4.\n    function asEuint4(euint128 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint128.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint4.\n    function asEuint4(euint256 value) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(euint256.unwrap(value), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint4 to ebool.\n    function asEbool(euint4 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint4'.\n    function asEuint4(ebool b) internal returns (euint4) {\n        return euint4.wrap(Impl.cast(ebool.unwrap(b), Common.euint4_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint8.\n    function asEuint8(euint4 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint4.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint8.\n    function asEuint8(euint16 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint8.\n    function asEuint8(euint32 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint8.\n    function asEuint8(euint64 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint8.\n    function asEuint8(euint128 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint8.\n    function asEuint8(euint256 value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), Common.euint8_t));\n    }\n\n    // Cast an encrypted integer from euint8 to ebool.\n    function asEbool(euint8 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted boolean.\n    function asEbool(einput inputHandle, bytes memory inputProof) internal returns (ebool) {\n        return ebool.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebool_t));\n    }\n\n    // Convert a plaintext value to an encrypted boolean.\n    function asEbool(uint256 value) internal returns (ebool) {\n        return ebool.wrap(Impl.trivialEncrypt(value, Common.ebool_t));\n    }\n\n    // Convert a plaintext boolean to an encrypted boolean.\n    function asEbool(bool value) internal returns (ebool) {\n        if (value) {\n            return asEbool(1);\n        } else {\n            return asEbool(0);\n        }\n    }\n\n    // Converts an 'ebool' to an 'euint8'.\n    function asEuint8(ebool value) internal returns (euint8) {\n        return euint8.wrap(Impl.cast(ebool.unwrap(value), Common.euint8_t));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(ebool a, bool b) internal returns (ebool) {\n        return ebool.wrap(Impl.and(ebool.unwrap(a), b ? 1 : 0, true));\n    }\n\n    // Evaluate and(a, b) and return the result.\n    function and(bool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.and(ebool.unwrap(b), a ? 1 : 0, true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(ebool a, bool b) internal returns (ebool) {\n        return ebool.wrap(Impl.or(ebool.unwrap(a), b ? 1 : 0, true));\n    }\n\n    // Evaluate or(a, b) and return the result.\n    function or(bool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.or(ebool.unwrap(b), a ? 1 : 0, true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(ebool a, bool b) internal returns (ebool) {\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), b ? 1 : 0, true));\n    }\n\n    // Evaluate xor(a, b) and return the result.\n    function xor(bool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), a ? 1 : 0, true));\n    }\n\n    function not(ebool a) internal returns (ebool) {\n        return ebool.wrap(Impl.not(ebool.unwrap(a)));\n    }\n\n    // Cast an encrypted integer from euint4 to euint16.\n    function asEuint16(euint4 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint4.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint16.\n    function asEuint16(euint8 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint16.\n    function asEuint16(euint32 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint16.\n    function asEuint16(euint64 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint16.\n    function asEuint16(euint128 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint16.\n    function asEuint16(euint256 value) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint16 to ebool.\n    function asEbool(euint16 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint16'.\n    function asEuint16(ebool b) internal returns (euint16) {\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), Common.euint16_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint32.\n    function asEuint32(euint4 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint4.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint32.\n    function asEuint32(euint8 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint32.\n    function asEuint32(euint16 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint32.\n    function asEuint32(euint64 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint32.\n    function asEuint32(euint128 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint32.\n    function asEuint32(euint256 value) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint32 to ebool.\n    function asEbool(euint32 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint32'.\n    function asEuint32(ebool b) internal returns (euint32) {\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), Common.euint32_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint64.\n    function asEuint64(euint4 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint4.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint64.\n    function asEuint64(euint8 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint64.\n    function asEuint64(euint16 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint64.\n    function asEuint64(euint32 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint64.\n    function asEuint64(euint128 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint64.\n    function asEuint64(euint256 value) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint64 to ebool.\n    function asEbool(euint64 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint64'.\n    function asEuint64(ebool b) internal returns (euint64) {\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), Common.euint64_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint128.\n    function asEuint128(euint4 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint4.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint128.\n    function asEuint128(euint8 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint128.\n    function asEuint128(euint16 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint128.\n    function asEuint128(euint32 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint128.\n    function asEuint128(euint64 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint256 to euint128.\n    function asEuint128(euint256 value) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint128 to ebool.\n    function asEbool(euint128 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint128'.\n    function asEuint128(ebool b) internal returns (euint128) {\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), Common.euint128_t));\n    }\n\n    // Cast an encrypted integer from euint4 to euint256.\n    function asEuint256(euint4 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint4.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint8 to euint256.\n    function asEuint256(euint8 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint16 to euint256.\n    function asEuint256(euint16 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint32 to euint256.\n    function asEuint256(euint32 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint64 to euint256.\n    function asEuint256(euint64 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint128 to euint256.\n    function asEuint256(euint128 value) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), Common.euint256_t));\n    }\n\n    // Cast an encrypted integer from euint256 to ebool.\n    function asEbool(euint256 value) internal returns (ebool) {\n        return ne(value, 0);\n    }\n\n    // Converts an 'ebool' to an 'euint256'.\n    function asEuint256(ebool b) internal returns (euint256) {\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), Common.euint256_t));\n    }\n\n    function neg(euint4 value) internal returns (euint4) {\n        return euint4.wrap(Impl.neg(euint4.unwrap(value)));\n    }\n\n    function not(euint4 value) internal returns (euint4) {\n        return euint4.wrap(Impl.not(euint4.unwrap(value)));\n    }\n\n    function neg(euint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\n    }\n\n    function not(euint8 value) internal returns (euint8) {\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\n    }\n\n    function neg(euint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\n    }\n\n    function not(euint16 value) internal returns (euint16) {\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\n    }\n\n    function neg(euint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\n    }\n\n    function not(euint32 value) internal returns (euint32) {\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\n    }\n\n    function neg(euint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\n    }\n\n    function not(euint64 value) internal returns (euint64) {\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\n    }\n\n    function neg(euint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\n    }\n\n    function not(euint128 value) internal returns (euint128) {\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\n    }\n\n    function neg(euint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\n    }\n\n    function not(euint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint4 integer.\n    function asEuint4(einput inputHandle, bytes memory inputProof) internal returns (euint4) {\n        return euint4.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint4_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint4 integer.\n    function asEuint4(uint256 value) internal returns (euint4) {\n        return euint4.wrap(Impl.trivialEncrypt(value, Common.euint4_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\n    function asEuint8(einput inputHandle, bytes memory inputProof) internal returns (euint8) {\n        return euint8.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint8_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint8 integer.\n    function asEuint8(uint256 value) internal returns (euint8) {\n        return euint8.wrap(Impl.trivialEncrypt(value, Common.euint8_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\n    function asEuint16(einput inputHandle, bytes memory inputProof) internal returns (euint16) {\n        return euint16.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint16_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint16 integer.\n    function asEuint16(uint256 value) internal returns (euint16) {\n        return euint16.wrap(Impl.trivialEncrypt(value, Common.euint16_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\n    function asEuint32(einput inputHandle, bytes memory inputProof) internal returns (euint32) {\n        return euint32.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint32_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint32 integer.\n    function asEuint32(uint256 value) internal returns (euint32) {\n        return euint32.wrap(Impl.trivialEncrypt(value, Common.euint32_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\n    function asEuint64(einput inputHandle, bytes memory inputProof) internal returns (euint64) {\n        return euint64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint64_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint64 integer.\n    function asEuint64(uint256 value) internal returns (euint64) {\n        return euint64.wrap(Impl.trivialEncrypt(value, Common.euint64_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\n    function asEuint128(einput inputHandle, bytes memory inputProof) internal returns (euint128) {\n        return euint128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint128_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint128 integer.\n    function asEuint128(uint256 value) internal returns (euint128) {\n        return euint128.wrap(Impl.trivialEncrypt(value, Common.euint128_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\n    function asEuint256(einput inputHandle, bytes memory inputProof) internal returns (euint256) {\n        return euint256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint256_t));\n    }\n\n    // Convert a plaintext value to an encrypted euint256 integer.\n    function asEuint256(uint256 value) internal returns (euint256) {\n        return euint256.wrap(Impl.trivialEncrypt(value, Common.euint256_t));\n    }\n\n    // Generates a random encrypted boolean.\n    function randEbool() internal returns (ebool) {\n        return ebool.wrap(Impl.rand(Common.ebool_t));\n    }\n\n    // Generates a random encrypted 4-bit unsigned integer.\n    function randEuint4() internal returns (euint4) {\n        return euint4.wrap(Impl.rand(Common.euint4_t));\n    }\n\n    // Generates a random encrypted 4-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint4(uint8 upperBound) internal returns (euint4) {\n        return euint4.wrap(Impl.randBounded(upperBound, Common.euint4_t));\n    }\n\n    // Generates a random encrypted 8-bit unsigned integer.\n    function randEuint8() internal returns (euint8) {\n        return euint8.wrap(Impl.rand(Common.euint8_t));\n    }\n\n    // Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\n        return euint8.wrap(Impl.randBounded(upperBound, Common.euint8_t));\n    }\n\n    // Generates a random encrypted 16-bit unsigned integer.\n    function randEuint16() internal returns (euint16) {\n        return euint16.wrap(Impl.rand(Common.euint16_t));\n    }\n\n    // Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\n        return euint16.wrap(Impl.randBounded(upperBound, Common.euint16_t));\n    }\n\n    // Generates a random encrypted 32-bit unsigned integer.\n    function randEuint32() internal returns (euint32) {\n        return euint32.wrap(Impl.rand(Common.euint32_t));\n    }\n\n    // Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\n        return euint32.wrap(Impl.randBounded(upperBound, Common.euint32_t));\n    }\n\n    // Generates a random encrypted 64-bit unsigned integer.\n    function randEuint64() internal returns (euint64) {\n        return euint64.wrap(Impl.rand(Common.euint64_t));\n    }\n\n    // Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\n        return euint64.wrap(Impl.randBounded(upperBound, Common.euint64_t));\n    }\n\n    // Generates a random encrypted 128-bit unsigned integer.\n    function randEuint128() internal returns (euint128) {\n        return euint128.wrap(Impl.rand(Common.euint128_t));\n    }\n\n    // Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\n        return euint128.wrap(Impl.randBounded(upperBound, Common.euint128_t));\n    }\n\n    // Generates a random encrypted 256-bit unsigned integer.\n    function randEuint256() internal returns (euint256) {\n        return euint256.wrap(Impl.rand(Common.euint256_t));\n    }\n\n    // Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\n    // The upperBound must be a power of 2.\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\n        return euint256.wrap(Impl.randBounded(upperBound, Common.euint256_t));\n    }\n\n    // Generates a random encrypted 512-bit unsigned integer.\n    function randEbytes64() internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.rand(Common.ebytes64_t));\n    }\n\n    // Generates a random encrypted 1024-bit unsigned integer.\n    function randEbytes128() internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.rand(Common.ebytes128_t));\n    }\n\n    // Generates a random encrypted 2048-bit unsigned integer.\n    function randEbytes256() internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.rand(Common.ebytes256_t));\n    }\n\n    // Convert an inputHandle with corresponding inputProof to an encrypted eaddress.\n    function asEaddress(einput inputHandle, bytes memory inputProof) internal returns (eaddress) {\n        return eaddress.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.euint160_t));\n    }\n\n    // Convert a plaintext value to an encrypted address.\n    function asEaddress(address value) internal returns (eaddress) {\n        return eaddress.wrap(Impl.trivialEncrypt(uint160(value), Common.euint160_t));\n    }\n\n    // Convert the given inputHandle and inputProof to an encrypted ebytes64 value.\n    function asEbytes64(einput inputHandle, bytes memory inputProof) internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes64_t));\n    }\n\n    // Left-pad a bytes array with zeros such that it becomes of length 64.\n    function padToBytes64(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length <= 64, \"Input exceeds 64 bytes\");\n        bytes memory result = new bytes(64);\n        uint256 paddingLength = 64 - input.length;\n        for (uint256 i = 0; i < paddingLength; i++) {\n            result[i] = 0;\n        }\n        for (uint256 i = 0; i < input.length; i++) {\n            result[paddingLength + i] = input[i];\n        }\n        return result;\n    }\n\n    // Convert a plaintext value - must be a bytes array of size 64 - to an encrypted Bytes64.\n    function asEbytes64(bytes memory value) internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.trivialEncrypt(value, Common.ebytes64_t));\n    }\n\n    // Convert the given inputHandle and inputProof to an encrypted ebytes128 value.\n    function asEbytes128(einput inputHandle, bytes memory inputProof) internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes128_t));\n    }\n\n    // Left-pad a bytes array with zeros such that it becomes of length 128.\n    function padToBytes128(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length <= 128, \"Input exceeds 128 bytes\");\n        bytes memory result = new bytes(128);\n        uint256 paddingLength = 128 - input.length;\n        for (uint256 i = 0; i < paddingLength; i++) {\n            result[i] = 0;\n        }\n        for (uint256 i = 0; i < input.length; i++) {\n            result[paddingLength + i] = input[i];\n        }\n        return result;\n    }\n\n    // Convert a plaintext value - must be a bytes array of size 128 - to an encrypted Bytes128.\n    function asEbytes128(bytes memory value) internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.trivialEncrypt(value, Common.ebytes128_t));\n    }\n\n    // Convert the given inputHandle and inputProof to an encrypted ebytes256 value.\n    function asEbytes256(einput inputHandle, bytes memory inputProof) internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.verify(einput.unwrap(inputHandle), inputProof, Common.ebytes256_t));\n    }\n\n    // Left-pad a bytes array with zeros such that it becomes of length 256.\n    function padToBytes256(bytes memory input) internal pure returns (bytes memory) {\n        require(input.length <= 256, \"Input exceeds 256 bytes\");\n        bytes memory result = new bytes(256);\n        uint256 paddingLength = 256 - input.length;\n        for (uint256 i = 0; i < paddingLength; i++) {\n            result[i] = 0;\n        }\n        for (uint256 i = 0; i < input.length; i++) {\n            result[paddingLength + i] = input[i];\n        }\n        return result;\n    }\n\n    // Convert a plaintext value - must be a bytes array of size 256 - to an encrypted Bytes256.\n    function asEbytes256(bytes memory value) internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.trivialEncrypt(value, Common.ebytes256_t));\n    }\n\n    // Return true if the enrypted address is initialized and false otherwise.\n    function isInitialized(eaddress v) internal pure returns (bool) {\n        return eaddress.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted value is initialized and false otherwise.\n    function isInitialized(ebytes64 v) internal pure returns (bool) {\n        return ebytes64.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted value is initialized and false otherwise.\n    function isInitialized(ebytes128 v) internal pure returns (bool) {\n        return ebytes128.unwrap(v) != 0;\n    }\n\n    // Return true if the enrypted value is initialized and false otherwise.\n    function isInitialized(ebytes256 v) internal pure returns (bool) {\n        return ebytes256.unwrap(v) != 0;\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebool a, ebool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        if (!isInitialized(b)) {\n            b = asEbool(false);\n        }\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bool b, ebool a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebool a, bool b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bool b, ebool a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbool(false);\n        }\n        uint256 bProc = b ? 1 : 0;\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bProc, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        if (!isInitialized(b)) {\n            b = asEaddress(address(0));\n        }\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(eaddress a, address b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(address b, eaddress a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(eaddress a, address b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(address b, eaddress a) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEaddress(address(0));\n        }\n        uint256 bProc = uint256(uint160(b));\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bProc, true));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebytes64 a, ebytes64 b) internal returns (ebytes64) {\n        return ebytes64.wrap(Impl.select(ebool.unwrap(control), ebytes64.unwrap(a), ebytes64.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebytes128 a, ebytes128 b) internal returns (ebytes128) {\n        return ebytes128.wrap(Impl.select(ebool.unwrap(control), ebytes128.unwrap(a), ebytes128.unwrap(b)));\n    }\n\n    // If 'control''s value is 'true', the result has the same value as 'a'.\n    // If 'control''s value is 'false', the result has the same value as 'b'.\n    function select(ebool control, ebytes256 a, ebytes256 b) internal returns (ebytes256) {\n        return ebytes256.wrap(Impl.select(ebool.unwrap(control), ebytes256.unwrap(a), ebytes256.unwrap(b)));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes64 a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes64 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(a), b, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bytes memory a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes64.unwrap(b), a, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes64 a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), ebytes64.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes64 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(a), b, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bytes memory a, ebytes64 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes64(padToBytes64(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes64.unwrap(b), a, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes128 a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes128 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(a), b, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bytes memory a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes128.unwrap(b), a, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes128 a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), ebytes128.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes128 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(a), b, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bytes memory a, ebytes128 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes128(padToBytes128(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes128.unwrap(b), a, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes256 a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(ebytes256 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(a), b, true));\n    }\n\n    // Evaluate eq(a, b) and return the result.\n    function eq(bytes memory a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.eq(ebytes256.unwrap(b), a, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes256 a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), ebytes256.unwrap(b), false));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(ebytes256 a, bytes memory b) internal returns (ebool) {\n        if (!isInitialized(a)) {\n            a = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(a), b, true));\n    }\n\n    // Evaluate ne(a, b) and return the result.\n    function ne(bytes memory a, ebytes256 b) internal returns (ebool) {\n        if (!isInitialized(b)) {\n            b = asEbytes256(padToBytes256(hex\"\"));\n        }\n        return ebool.wrap(Impl.ne(ebytes256.unwrap(b), a, true));\n    }\n\n    // cleans the transient storage of ACL containing all the allowedTransient accounts\n    // to be used for integration with Account Abstraction or when bundling UserOps calling the FHEVMCoprocessor\n    function cleanTransientStorage() internal {\n        return Impl.cleanTransientStorage();\n    }\n\n    function isAllowed(ebool value, address account) internal view returns (bool) {\n        return Impl.isAllowed(ebool.unwrap(value), account);\n    }\n    function isAllowed(euint4 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint4.unwrap(value), account);\n    }\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint8.unwrap(value), account);\n    }\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint16.unwrap(value), account);\n    }\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint32.unwrap(value), account);\n    }\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint64.unwrap(value), account);\n    }\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint128.unwrap(value), account);\n    }\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(euint256.unwrap(value), account);\n    }\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\n        return Impl.isAllowed(eaddress.unwrap(value), account);\n    }\n\n    function isAllowed(ebytes256 value, address account) internal view returns (bool) {\n        return Impl.isAllowed(ebytes256.unwrap(value), account);\n    }\n\n    function isSenderAllowed(ebool value) internal view returns (bool) {\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint4 value) internal view returns (bool) {\n        return Impl.isAllowed(euint4.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\n    }\n\n    function isSenderAllowed(ebytes256 value) internal view returns (bool) {\n        return Impl.isAllowed(ebytes256.unwrap(value), msg.sender);\n    }\n\n    function allow(ebool value, address account) internal {\n        Impl.allow(ebool.unwrap(value), account);\n    }\n\n    function allowThis(ebool value) internal {\n        Impl.allow(ebool.unwrap(value), address(this));\n    }\n\n    function allow(euint4 value, address account) internal {\n        Impl.allow(euint4.unwrap(value), account);\n    }\n\n    function allowThis(euint4 value) internal {\n        Impl.allow(euint4.unwrap(value), address(this));\n    }\n\n    function allow(euint8 value, address account) internal {\n        Impl.allow(euint8.unwrap(value), account);\n    }\n\n    function allowThis(euint8 value) internal {\n        Impl.allow(euint8.unwrap(value), address(this));\n    }\n\n    function allow(euint16 value, address account) internal {\n        Impl.allow(euint16.unwrap(value), account);\n    }\n\n    function allowThis(euint16 value) internal {\n        Impl.allow(euint16.unwrap(value), address(this));\n    }\n\n    function allow(euint32 value, address account) internal {\n        Impl.allow(euint32.unwrap(value), account);\n    }\n\n    function allowThis(euint32 value) internal {\n        Impl.allow(euint32.unwrap(value), address(this));\n    }\n\n    function allow(euint64 value, address account) internal {\n        Impl.allow(euint64.unwrap(value), account);\n    }\n\n    function allowThis(euint64 value) internal {\n        Impl.allow(euint64.unwrap(value), address(this));\n    }\n\n    function allow(euint128 value, address account) internal {\n        Impl.allow(euint128.unwrap(value), account);\n    }\n\n    function allowThis(euint128 value) internal {\n        Impl.allow(euint128.unwrap(value), address(this));\n    }\n\n    function allow(euint256 value, address account) internal {\n        Impl.allow(euint256.unwrap(value), account);\n    }\n\n    function allowThis(euint256 value) internal {\n        Impl.allow(euint256.unwrap(value), address(this));\n    }\n\n    function allow(eaddress value, address account) internal {\n        Impl.allow(eaddress.unwrap(value), account);\n    }\n\n    function allowThis(eaddress value) internal {\n        Impl.allow(eaddress.unwrap(value), address(this));\n    }\n\n    function allow(ebytes64 value, address account) internal {\n        Impl.allow(ebytes64.unwrap(value), account);\n    }\n\n    function allowThis(ebytes64 value) internal {\n        Impl.allow(ebytes64.unwrap(value), address(this));\n    }\n\n    function allow(ebytes128 value, address account) internal {\n        Impl.allow(ebytes128.unwrap(value), account);\n    }\n\n    function allowThis(ebytes128 value) internal {\n        Impl.allow(ebytes128.unwrap(value), address(this));\n    }\n\n    function allow(ebytes256 value, address account) internal {\n        Impl.allow(ebytes256.unwrap(value), account);\n    }\n\n    function allowThis(ebytes256 value) internal {\n        Impl.allow(ebytes256.unwrap(value), address(this));\n    }\n\n    function allowTransient(ebool value, address account) internal {\n        Impl.allowTransient(ebool.unwrap(value), account);\n    }\n\n    function allowTransient(euint4 value, address account) internal {\n        Impl.allowTransient(euint4.unwrap(value), account);\n    }\n\n    function allowTransient(euint8 value, address account) internal {\n        Impl.allowTransient(euint8.unwrap(value), account);\n    }\n\n    function allowTransient(euint16 value, address account) internal {\n        Impl.allowTransient(euint16.unwrap(value), account);\n    }\n\n    function allowTransient(euint32 value, address account) internal {\n        Impl.allowTransient(euint32.unwrap(value), account);\n    }\n\n    function allowTransient(euint64 value, address account) internal {\n        Impl.allowTransient(euint64.unwrap(value), account);\n    }\n\n    function allowTransient(euint128 value, address account) internal {\n        Impl.allowTransient(euint128.unwrap(value), account);\n    }\n\n    function allowTransient(euint256 value, address account) internal {\n        Impl.allowTransient(euint256.unwrap(value), account);\n    }\n\n    function allowTransient(eaddress value, address account) internal {\n        Impl.allowTransient(eaddress.unwrap(value), account);\n    }\n\n    function allowTransient(ebytes64 value, address account) internal {\n        Impl.allowTransient(ebytes64.unwrap(value), account);\n    }\n\n    function allowTransient(ebytes128 value, address account) internal {\n        Impl.allowTransient(ebytes128.unwrap(value), account);\n    }\n\n    function allowTransient(ebytes256 value, address account) internal {\n        Impl.allowTransient(ebytes256.unwrap(value), account);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "evmVersion": "cancun",
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}